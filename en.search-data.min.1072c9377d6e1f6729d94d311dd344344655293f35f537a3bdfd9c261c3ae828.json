[{"id":0,"href":"/docs/zkdocs/protocol-primitives/random-sampling/","title":"Random Sampling","section":"Protocol primitives","content":"Random sampling #  In most protocols, it is required to sample uniformly from groups like $\\zq$ or $\\zqs$. Here we will describe how to sample in these specific groups, and a general procedure to sample via rejection sampling.\nUniform sampling in $\\zq$ #  Since we identify the elements of $\\zq$ with the set of integers $\\range{q}$, to uniformly sample we only need to sample from the set $\\range{q}$.\nWe should always use a suitable cryptographic random number library to sample uniformly. For instance, in python, we can use secrets.\n1 2 3 4  import secrets  def sample_Zq():  return secrets.randbelow(q)   Never do this: When you only have access to sampling elements of a fixed bit-size but want to sample over $\\z{1337}$ do not do this:\n1 2  def wrong_sampling():  return sample_32_bits() % 1337   The wrong_sampling function introduces modulo-bias in the generation of elements, and some elements will be more likely to appear than others. In these cases you need to use rejection sampling.\n Rejection sampling #  Suppose we know how to sample from a set $S$ and would like to sample from a subset $T\\subseteq S$. To do this, we need to check membership in $T$ and perform rejection sampling. In a loop:\n sample element $e \\in S$. if $e \\in T$, return $e$, otherwise repeat step 1.  This is how we must perform sampling in $\\zq$ if we cannot use a library like secrets. In this case, rejection sampling would look like this:\n1 2 3 4 5  def correct_sampling():  while True:  e = sample_32_bits()  if e \u0026gt;= 0 and e \u0026lt; 1337:  return e   Depending on the set we can sample from, this method can take longer, but in practice, we should always be able to sample from spaces only slightly larger than our target space.\nUniform sampling in $\\zqs$ #  Sampling in $\\zqs$ requires an extra step. The elements of $\\zqs$ are the elements invertible modulo $q$ and for $e$ to be invertible means that $\\gcd(e, q) = 1$. So, to obtain these elements we need to perform rejection sampling. In a loop,\n sample element $e \\in \\zq$ using the previous section. if $\\gcd(e, q) = 1$ return $e$, otherwise repeat step 1.  1 2 3 4 5 6 7 8  import secrets import math  def sample_Zqstar():  while True:  e = sample_Zq()  if math.gcd(e, q) == 1:  return e   Note: Since $\\gcd(0, q)$ is never 1, we can sample $e$ from the set $\\rangeone{q}$.  "},{"id":1,"href":"/docs/zkdocs/","title":"Introduction","section":"Docs","content":"Introduction #  Zero-knowledge protocols #  ZKDocs provides comprehensive, detailed, and interactive documentation on zero-knowledge proof systems and related primitives.\nAt Trail of Bits, we audit many implementations of non-standardized cryptographic protocols and often find the same issues. As we discovered more instances of these bugs, we wanted to find a way to prevent them in the future. Unfortunately, for these protocols, the burden is on the developers to figure out all of the low-level implementation details and security pitfalls.\nWe hope that ZKDocs can fill in this gap and benefit the larger cryptography community.\nComprehensive #  We aim to be both self-contained and comprehensive in the topics related to zero-knowledge proof systems, from descriptions of simple systems like Schnorrâ€™s identification protocol, to complex proof systems like Paillier-Blum modulus. We also cover cryptographic primitives such as: random sampling, Fiat-Shamir transformation, and Shamir\u0026rsquo;s Secret Sharing.  Detailed #  We describe each protocol in great detail, including all necessary setup, sanity-checks, auxiliary algorithms, further references, and potential security pitfalls with their associated severity.   Interactive #  The protocol descriptions are interactive, letting you modify variable names. This allows you to match the variable names in ZKdocs\u0026rsquo; specification to the variable names in your code, making it easier to find bugs and missing assertions.\nInteractivity features:\n Click on $\\varX$ to highlight the variable across the document. Try it! Type or paste with $\\varX$ highlighted to edit $\\varX$\u0026rsquo;s name. Press Enter or Escape to stop editing. Press the Reset variables names button to reset the names of all variables on the current page (variable names are independent across different pages)   Contribute #  We will continue to add more proof systems like Range proofs, STARK, and Bulletproofs.\nFeel free to open issues and suggest new protocols that you would like to see added in ZKDocs.\n"},{"id":2,"href":"/docs/zkdocs/notation/","title":"Notation \u0026 Definitions","section":"Introduction","content":"Notation and Definitions #  This page is a glossary for notation and concepts present in the documentation.\nSets, Groups, and Special Functions #   $\\mathbb{Z}$ is the set of integers, $\\{\\ldots, -2, -1, 0, 1, 2, \\ldots\\}$. $\\naturals$ is the set of integers greater of equal than 0, $\\{0, 1, 2, \\ldots\\}$. $\\range{b}$ is the finite set of integers $\\{0, \\ldots, b-1\\}$. $\\gcd(n, m)$ is the nonnegative greatest common divisor of integers $n$ and $m$; when $\\gcd(n, m) = 1$, $n$ and $m$ are said to be coprime. $\\z{n}$ are the integers modulo $n$, a set associated with the equivalence classes of integers $\\{0, 1, \\ldots, n-1\\}$. $\\zns{n}$ is the multiplicative group of integers modulo $n$: an element $e$ from $\\z{n}$ is in $\\zns{n}$ iff $\\gcd(e, n) = 1$, that is $\\zns{n} = \\{e \\in \\z{n}: \\gcd(e, n) = 1\\}$. When $n$ is prime, then $\\zns{n} = \\{1, \\ldots, n-1\\}$. $\\field{p}$ is the finite field of order $p$; when $p$ is a prime number, these are the integers modulo $p$, $\\z{p}$; when $p$ is a prime power $q^k$, these are Galois fields. $\\varphi(n)$ is Euler\u0026rsquo;s totient function; for $n\\geq 1$, it is the number of integers in $\\{1,\\ldots, n\\}$ coprime with $n.$ $|S|$ is the order of a set $S$, i.e., its number of elements. For example, $|\\zns{n}| = \\varphi(n)$, and for a prime $n$, $|\\zns{n}| = n-1$.  Number-theory #   $J(w, n)\\in \\{-1, 0, 1\\}$ is the Jacobi symbol of $w$ modulo $n$, only defined for positive and odd $n$. $J_n$ is the set of elements of $\\zns{n}$ with Jacobi symbol $1$. $QR_n$ is the set of quadratic residues modulo $n$, which are elements that have a square-root, i.e., $QR_n = \\{e \\in \\z{n} : \\exists r . r^2 = e \\mod n\\}$.  Sampling #  In protocol specifications, we will often need to uniformly sample elements from sets. We will use the following notation:\n $\\sampleGeneric{x}{X}$, where $x$ is uniformly sampled from the set $X$.  Consider reading the section on Random Sampling to learn how to correctly sample a number uniformly using rejection sampling, avoiding the modulo-bias issue.\nAssertions #  We will use assertions in protocol descriptions. When the assertions do not hold, the protocol must abort to avoid leaking secret information.\n $a \\equalQ b$, requires $a=b$, and aborts otherwise $a \\gQ b$, requires $a\u0026gt;b$, and aborts otherwise $a \\inQ S$, requires that $a$ is in the set $S$, and aborts otherwise.  Implementations of number-theoretic algorithms #  In general, we highly recommend the Handbook of Applied Cryptography, which has detailed descriptions of most algorithms.\nHash Functions #   $\\hash{\\cdot}$ is a cryptographically secure domain-separated hash function. $\\hashbit{\\cdot}{k}$ is a cryptographically secure domain-separated hash function with specific output-size of $k$-bits.  Find more details on the particular hash functions in Nothing-up-my-sleeve constructions\n"},{"id":3,"href":"/docs/zkdocs/zero-knowledge-protocols/schnorr/","title":"Schnorr's identification protocol","section":"Zero-knowledge protocols","content":"Schnorr\u0026rsquo;s identification protocol #  Schnorr\u0026rsquo;s identification protocol is the simplest example of a zero-knowledge protocol. With it, $\\varprover$ can convince $\\varverifier$ that they know the discrete logarithm $\\varx$ of some value $\\varh = \\varg^\\varx$, without revealing $\\varx$.\nGoal: $\\varprover$ convinces $\\varverifier$ that they know $\\varx$ such that $\\varh = \\varg^\\varx$.   Public input: cyclic group $\\cgroup$ of prime order $\\varq$, a $\\cgroup$ generator $\\varg$ and $\\varh\\in \\cgroup$. Private input: $\\varprover$ knows secret $\\varx\\in\\zq$ such that $\\varh = \\varg^\\varx$.  Multiplicative notation Interactive protocol #  The Schnorr interactive identification protocol\n$$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\samplezqs{\\varr}} \\alicework{\\varu = \\varg^\\varr} \\alicebob{}{\\varu}{} \\bobwork{\\sample{\\varc}} \\bobalice{}{\\varc}{} \\alicework{\\varz = \\varr + \\varx\\cdot \\varc} \\alicebob{}{\\varz}{} \\bobwork{\\varg^{\\varz} \\equalQ \\varu \\cdot \\varh^\\varc } \\end{array} $$\n Non-interactive protocol #  We can transform this identification scheme into a non-interactive protocol using the Fiat-Shamir heuristic. Here, the prover creates the random challenge $c$ hashing all public values $\\{\\varg, \\varq, \\varh, \\varu\\}$.\n$$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\samplezqs{\\varr}} \\alicework{\\varu = \\varg^\\varr} \\alicework{\\varc = \\hash{\\varg, \\varq, \\varh, \\varu}} \\alicework{\\varz = \\varr + \\varx\\cdot \\varc} \\alicebob{}{\\varu, \\varc, \\varz}{} \\bobwork{\\varc \\equalQ \\hash{\\varg, \\varq, \\varh, \\varu}} \\bobwork{\\varg^\\varz \\equalQ \\varu \\cdot \\varh ^\\varc } \\end{array} $$\nAdditive notation Interactive protocol #  The Schnorr interactive identification protocol\n$$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\samplezqs{\\varr}} \\alicework{\\varu = \\varr\\cdot\\varg} \\alicebob{}{\\varu}{} \\bobwork{\\sample{\\varc}} \\bobalice{}{\\varc}{} \\alicework{\\varz = \\varr + \\varx\\cdot \\varc} \\alicebob{}{\\varz}{} \\bobwork{\\varz\\cdot\\varg \\equalQ \\varu + \\varc\\cdot\\varh } \\end{array} $$\n Non-interactive protocol #  We can transform this identification scheme into a non-interactive protocol using the Fiat-Shamir heuristic. Here, the prover creates the random challenge $c$ hashing all public values $\\{\\varg, \\varq, \\varh, \\varu\\}$.\n$$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\samplezqs{\\varr}} \\alicework{\\varu = \\varr\\cdot \\varg} \\alicework{\\varc = \\hash{\\varg, \\varq, \\varh, \\varu}} \\alicework{\\varz = \\varr + \\varx\\cdot \\varc} \\alicebob{}{\\varu, \\varc, \\varz}{} \\bobwork{\\varc \\equalQ \\hash{\\varg, \\varq, \\varh, \\varu}} \\bobwork{\\varz \\cdot \\varg \\equalQ \\varu + \\varc\\cdot\\varh} \\end{array} $$\n Security pitfalls #   Verifier trusts prover: On the verification check, the verifier uses $g$ and $q$ provided with the proof instead of using publicly known values. On the NI version, the verifier assumes that the hash $\\varc$ is correctly computed and does not compute it themself. Both are high severity issues since $\\varprover$ can forge proofs. Weak Fiat-Shamir transformation: In the non-interactive protocol, it is a common occurrence that some parameters are missing on the hash computation $\\hash{\\varg, \\varq, \\varh, \\varu}$:  $\\varh$ or $\\varu$ missing: high severity issue. Read Fiat-Shamir transformation for more details. $\\varg$ or $\\varq$ missing: usually no issue, but it might be one if the Verifier uses these parameters directly from the proof structure. This way, the prover can provide bad generators or orders to forge the proof.   Weak randomness: Bad randomness may cause the secret $\\varx$ to leak. If $\\varr$ is reused twice with two different interactive challenges, or different data on the non-interactive version then $$ \\frac{\\varz - \\varz\u0026rsquo;}{\\varc-\\varc\u0026rsquo;} = \\frac{\\varr -\\varr + \\varx\\cdot(\\varc - \\varc\u0026rsquo;)}{\\varc-\\varc\u0026rsquo;} = \\varx $$ Replay attacks: After a non-interactive proof is public, it will always be valid and anyone could pretend to know the secret value. To prevent this, consider adding the ID of both the prover and the verifier inside of the Fiat-Shamir hash computation.  Security assumptions #   Hash function: The hash function should be either TupleHash or SHA-256 where each input is domain separated with a unique string together with the length of each element. Hardness of the discrete logarithm: The order of the cyclic group $\\cgroup$ should be at least $\\varq\u0026gt;2^{K}$ where $K=256$, for a generic group $\\cgroup$. If $\\cgroup$ is a (prime-order) subgroup of $\\zps$, then $p$ should be greater than $2^{\\kappa}$ for $\\kappa=3072$ to avoid subexponential attacks based on the extra structure of $\\zps$. Note that this requires $p - 1 = q\\cdot r$ with some potentially composite number $r$. Refer to table 2 (pp. 54-55) of the NIST recommendations for an overview of different bit security levels for finite field discrete logarithms.  "},{"id":4,"href":"/docs/zkdocs/zero-knowledge-protocols/schnorr-variants/","title":"Variants of Schnorr's identification protocol","section":"Zero-knowledge protocols","content":"Variants of Schnorr\u0026rsquo;s identification protocol #  All variants of Schnorr\u0026rsquo;s protocol prove the knowledge of an $\\varx$ such that $\\varh = \\varg^\\varx$ for a public $\\varh$.\nThe differences are tradeoffs between the size of the proof statements and a more costly proof verification, and smaller communication overhead.\nGoal: $\\varprover$ convinces $\\varverifier$ that they know $\\varx$ such that $\\varh = \\varg^\\varx$   Public input: cyclic group $\\cgroup$ of prime order $\\varq$, a $\\cgroup$ generator $\\varg$ and $\\varh\\in \\cgroup$. Private input: $\\varprover$ knows secret $\\varx\\in\\zq$ such that $\\varh = \\varg^\\varx$.  We present all variants in their non-interactive version.\nNon-interactive protocols #  Original #  $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleNs{\\varr}{\\varq}} \\alicework{\\varu = \\varg^\\varr} \\alicework{\\varc = \\hash{\\varg, \\varq, \\varh, \\varu}} \\alicework{\\varz = \\varr + \\varx\\cdot \\varc} \\alicebob{}{\\varu, \\varc, \\varz}{} \\bobwork{\\varc \\equalQ \\hash{\\varg, \\varq, \\varh, \\varu}} \\bobwork{\\varg^\\varz \\equalQ \\varu \\cdot \\varh ^\\varc } \\end{array} $$  Slim Original #  In this variant, the prover does not send the value of $\\varc$ which has to be computed by the verifier. $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleNs{\\varr}{\\varq}} \\alicework{\\varu = \\varg^\\varr} \\alicework{\\varc = \\hash{\\varg, \\varq, \\varh, \\varu}} \\alicework{\\varz = \\varr + \\varx\\cdot \\varc} \\alicebob{}{\\varu, \\varz}{} \\bobwork{\\bar{\\varc} = \\hash{\\varg, \\varq, \\varh, \\varu}} \\bobwork{\\varg^\\varz \\equalQ \\varu \\cdot \\varh ^\\overline{\\varc} } \\end{array} $$  Subtract #  In this variant, the prover uses a subtraction to compute the value of $\\varz$.\n$$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleNs{\\varr}{\\varq}} \\alicework{\\varu = \\varg^\\varr} \\alicework{\\varc = \\hash{\\varg, \\varq, \\varh, \\varu}} \\alicework{\\varz = \\varr - \\varx\\cdot \\varc} \\alicebob{}{\\varu, \\varc, \\varz}{} \\bobwork{\\varc \\equalQ \\hash{\\varg, \\varq, \\varh, \\varu}} \\bobwork{\\varg^\\varz \\cdot \\varh ^\\varc \\equalQ \\varu } \\end{array} $$  Subtract + Derive #  In this variant, the prover uses a subtraction to compute the value of $\\varz$ and does not send $\\varu$, which the verifier derives from the values they know.\n$$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleNs{\\varr}{\\varq}} \\alicework{\\varu = \\varg^\\varr} \\alicework{\\varc = \\hash{\\varg, \\varq, \\varh, \\varu}} \\alicework{\\varz = \\varr - \\varx\\cdot \\varc} \\alicebob{}{\\varc, \\varz}{} \\bobwork{\\bar{\\varu} = \\varg^\\varz \\cdot \\varh^\\varc} \\bobwork{\\bar{\\varc} = \\hash{\\varg, \\varq, \\varh, \\bar{\\varu}}} \\bobwork{\\varc \\equalQ \\bar{\\varc} } \\end{array} $$ Security pitfalls #  These variants suffer from the same pitfalls as the original Schnorr scheme, with some adjustments when $\\varz$ is computed with a subtraction:\n Verifier trusts prover:  $\\varverifier$ uses $g$ and $q$ provided in the proof instead of using publicly known values. When the $\\varprover$ sends $\\varc$, if the $\\varverifier$ assumes that the hash $\\varc$ is correctly computed and does not compute it themself. Both are high severity issues since $\\varprover$ can forge proofs.   Weak Fiat-Shamir transformation: It is a common issue that some parameters are missing on the hash computation $\\hash{\\varg, \\varq, \\varh, \\varu}$:  $\\varh$ or $\\varu$ missing: high severity issue. Read Fiat-Shamir transformation for more details. $\\varg$ or $\\varq$ missing: usually no issue, but it might be one if the Verifier uses these parameters directly from the proof structure. This way, the prover can provide bad generators or orders to forge the proof.   Weak randomness: Bad randomness may cause the secret $\\varx$ to leak. If $\\varr$ is reused twice with two different non-interactive challenges then: $$ \\frac{\\varz - \\varz\u0026rsquo;}{\\varc-\\varc\u0026rsquo;} = \\frac{\\varr -\\varr + \\varx\\cdot(\\varc - \\varc\u0026rsquo;)}{\\varc-\\varc\u0026rsquo;} = \\varx \\enspace,$$ or when $\\varz$ is computed with a subtraction: $$ \\frac{\\varz - \\varz\u0026rsquo;}{\\varc\u0026rsquo;-\\varc} = \\frac{\\varr -\\varr + \\varx\\cdot(\\varc\u0026rsquo; - \\varc)}{\\varc\u0026rsquo;-\\varc} = \\varx \\enspace.$$ Replay attacks: After a non-interactive proof is public, it will always be valid and anyone could pretend to know the secret value. To prevent this, consider adding the ID of both the prover and the verifier inside of the Fiat-Shamir hash computation.  "},{"id":5,"href":"/docs/zkdocs/zero-knowledge-protocols/","title":"Zero-knowledge protocols","section":"Introduction","content":"Introduction #  Zero-knowledge protocols #  Here, we provide uniform, detailed descriptions to several zero-knowledge protocols. We include: necessary setup, security pitfalls and associated severity, safe parameter choices, and original references.\n  Schnorr\u0026#39;s identification protocol  The zero-knowledge proof for a discrete-logarithm in a prime modulo.   Variants of Schnorr\u0026#39;s identification protocol  Common variants of Schnorr\u0026rsquo;s protocol.   Number is product of two primes  Prove that a number is the product of two primes. We show two proofs of this: one for generic primes, and another, more efficient, when primes are congruent with 3 modulo 4.   Girault\u0026#39;s identification protocol  A statistical zero-knowledge proof for discrete-logarithm in a composite modulo.   Short factoring proofs  Proof of knowledge of the factorization of an integer.   "},{"id":6,"href":"/docs/zkdocs/protocol-primitives/fiat-shamir/","title":"Fiat-Shamir transformation","section":"Protocol primitives","content":"Fiat-Shamir transformation #  Overview #  It turns out that in practice, most zero-knowledge proofs tend to have the same three-step structure:\n The prover first generates some random value, the commitment, and sends it to the verifier. The verifier responds with a challenge value generated uniformly at random. The prover computes the final proof based on both the commitment and challenge.  As you can tell, this structure is interactive, meaning that the prover requires a response from the verifier before they can complete their proof, which is not ideal for most applications. Fortunately, provers can avoid this by using the Fiat-Shamir heuristic (sometimes referred to as the Fiat-Shamir transformation), developed by Amos Fiat and Adi Shamir.\nThe idea behind the Fiat-Shamir transformation is that instead of having the verifier send a random challenge value to the prover, the prover can compute this value themselves by using a random function, such as a cryptographic hash function.\nExample: In the Schnorr protocol, we have an interactive and non-interactive version. In the interactive version, the prover sends their random commitment, $u = g^r$, and the verifier responds with a challenge value, $c$, that they generate uniformly at random. In the non-interactive version, the prover generates $c$ themselves by computing a hash over all of the public values, $c = \\hash{g,q,h,u}$. As we will discuss, the hash must include all of these values.  If you\u0026rsquo;d like to read more about this, we\u0026rsquo;ve written a blog post describing how they work in more detail.\nWhat can go wrong? #  This transformation may seem straightforward, but unfortunately, it tends to be very tricky in practice. In particular, the prover generates the random challenge value using a cryptographic hash function- but what are the inputs? It turns out that if you choose the wrong inputs, it usually means your proof system is broken. To see this, let\u0026rsquo;s look at Schnorr\u0026rsquo;s protocol as an example.\nBad example, NEVER DO THIS: Recall that in the Schnorr protocol, the prover generates their random commitment, $u = g^r$, computes the challenge value, $c$, and then computes the final proof $z = r + x\\cdot c$, where $x$ is the secret value corresponding to their public key, $h = g^x$. Let\u0026rsquo;s say the implementation is incorrect, and the challenge value, $c$, is not computed using the public key, $h$, and instead it\u0026rsquo;s computed as $c = \\hash{g,q,u}$. It turns out that malicious provers can now forge proofs by doing the following attack:\n Set the commitment value, $u$, to be some public key that you do not know the secret key for. Compute the challenge value $c = \\hash{g,q,u}$. Set the proof $z$ to be a random value, and then compute your public key to be $h = (\\frac{g^z}{u})^{\\frac{1}{c}}$ Send $u,c,z$ to the verifier.  The verifier then performs their two checks: $c \\equalQ \\hash{g,q,u}$ and $g^z \\equalQ u\\cdot h^c$. The first check will pass as they are both the same, and the second check will pass because of how we constructed $z$, $u$, and $h$.\nSince we set $u$ to be some value we do not know the secret key for, we also will not know the secret key for $h$, which means we have forged our proof of knowledge.\nNote: This attack does not allow you to forge proofs for any public key, this only works for random public keys. This tends not to be problematic when Schnorr proofs as a proof of knowledge in the typical public-key model. However, this can be very problematic when these proofs are used in other scenarios, such as a cryptographic voting system.\n Recommendations #  Rule of thumb #  The exact inputs required for the hash function will be different for every zero-knowledge proof system. The general rule of thumb to follow is to include all of the public information and all elements in the proof transcript up until that point inside the hash function.\nIn the Schnorr protocol, the public information is the public key, $h$, and the parameters related to the group being used, $g$ and $q$, and the proof transcript also includes the commitment value, $u$, and so we include all of those values in our hash computation.  For short factoring proof protocol, it\u0026rsquo;s a bit more complicated. The public information is the number the prover can factor, $N$, so this must be included. What about transcript values? In this scheme, the prover does a bit more work before computing the challenge compared to the Schnorr protocol. Specifically, they generate a random value ($r$), a series of values ($z_i$) using the nothing-up-my-sleeve construction, and then they compute $X = \\hash{\\bunchi{z_i^r \\mod N}}$ (this is not the Fiat-Shamir challenge). Since both the $X$ value and the set of $z_i$ values will be known to the verifier (i.e., they are part of the transcript), these must also be included in the hash computation. So, the correct challenge computation is $e = \\hash{N, \\bunchi{z_i}, X}$.\nNote: In the short factoring proof and in Girault\u0026rsquo;s scheme, the Fiat-Shamir challenge needs to additionally be of a specific bit-size. So, the correct computation is actually $e = \\hashbit{N, \\bunchi{z_i}, X}{k}$.\n Remember: Always include all public information and all transcript values. When in doubt, consult ZKDocs!\nPreventing replay attacks #  Just like digital signatures, zero-knowledge proofs can also be susceptible to replay attacks. As is the case for other replay attacks, the severity of these replay attacks will be highly application and context-specific.\nIf you believe replay attacks could be severe for your application, you might be able to use the Fiat-Shamir transformation to protect yourself. Specifically, suppose your application has some notion of identity tied to each party (a unique party ID, for example). In that case, you should include the ID of the prover and the verifier inside of the Fiat-Shamir hash computation. Then, when the verifier verifies the proof, they should also check that the IDs used in the hash function match the ID of themself and the prover. This will prevent other malicious parties from replaying any proof that they did not produce themselves.\n"},{"id":7,"href":"/docs/zkdocs/zero-knowledge-protocols/product-primes/square-freeness/","title":"Number is square-free","section":"Number is product of two primes","content":"Number is square-free #  To prove that a number is the product of two distinct primes, the first step is showing that the number is free of squares, i.e., that $\\varN$ is not of the form $\\varN = p^2 r$.\nThis proof shows in zero-knowledge \u0026ndash;without revealing the factors of the number\u0026ndash; that an element belongs to the set $$\\sqfree = \\{\\varN \\in \\naturals : \\text{there is no prime }p \\text{ such that }p^2|N \\}.$$\nThe protocol uses the fact that an honest prover can calculate $\\varN$-th roots of arbitrary numbers in $\\z{\\varN}$.\nGoal: $\\varprover$ convinces $\\varverifier$ that $\\varN$ is square-free without revealing its factorization.   Public input: $\\varN\\in\\naturals$ Private input: $\\varprover$ knows the factorization of $\\varN = \\varp\\varq$ Security parameters: $\\alpha, \\kappa, m = \\ceil{\\kappa/ \\log_2 \\alpha}$  The protocol uses the constant $\\displaystyle\\Pi_\\alpha = \\prod_\\underset{p\\text{ prime}}{p\u0026lt;\\alpha} p$, the product of the primes smaller than $\\alpha$.\nWe assume that both parties agree with the security parameters $\\alpha, \\kappa$ and $m$ prior to the execution of the protocol.\nInteractive protocol (HVZK) #  Security note: The protocol is zero-knowledge (does not reveal the factorization of $\\varN$) only when the verifier is honest and generates each $\\rhovar_i$ randomly. If the verifier choses these values maliciously they can recover the factorization of $\\varN$. If your attacker model takes this into consideration, use the non-interactive version. More details on Using HVZKP in the wrong context.  $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\bobwork{\\sampleN{\\rhovar_i}{\\varN}, \\text{ for }i=1,\\ldots,m} \\bobalice{}{\\{\\rhovar_i\\}_{i=1}^m}{} \\alicework{\\sigmavar_i = (\\rhovar_i)^{\\varN^{-1}\\mod \\varphi(\\varN)} \\mod \\varN,} \\alicework{\\text{ for }i=1,\\ldots,m} \\alicebob{}{\\{\\sigmavar_i\\}_{i=1}^m}{} \\bobwork{\\varN \\gQ 1} \\bobwork{\\gcd(\\varN, \\Pi_\\alpha) \\equalQ 1} \\bobwork{\\sigmavar_i \\gQ 0,} \\bobwork{\\rhovar_i \\equalQ \\sigmavar_i^\\varN \\mod \\varN,} \\bobwork{\\text{ for }i=1,\\ldots,m} \\end{array} $$  Non-interactive protocol #  The non-interactive version of the protocol replaces the verifier-side sampling of $\\rhovar_i$ elements and generates them using the Fiat-Shamir transformation. The participants only exchange one message, and there is no risk of leaking the factorization of $\\varN$ using maliciously chosen $\\rhovar_i$ values. $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\rhovar_i = \\mathsf{gen}_\\rhovar(\\z{\\varN}, \\{\\varN,i\\})} \\alicework{\\sigmavar_i = (\\rhovar_i)^{\\varN^{-1}\\mod \\varphi(\\varN)} \\mod \\varN,} \\alicework{\\text{ for }i=1,\\ldots,m} \\alicebob{}{\\{\\sigmavar_i\\}_{i=1}^m}{} \\bobwork{\\varN \\gQ 1} \\bobwork{\\gcd(\\varN, \\Pi_\\alpha) \\equalQ 1} \\bobwork{\\sigmavar_i \\gQ 0,} \\bobwork{\\rhovar_i = \\mathsf{gen}_\\rhovar(\\z{\\varN}, \\{\\varN,i\\})} \\bobwork{\\rhovar_i \\equalQ \\sigmavar_i^\\varN \\mod \\varN,} \\bobwork{\\text{ for }i=1,\\ldots,m} \\end{array} $$ Security pitfalls #   Using the interactive protocol in a malicious verifier context: high severity issue which allows factoring $\\varN$; see Using HVZKP in the wrong context. Sampling $\\rhovar_i$ values uniformly and not using honest generation: high severity issue that allows $\\varprover$ to forge proofs by sampling $\\sampleSet{\\sigmavar_i}{\\z\\varN}$ and setting $\\rhovar_i = \\sigmavar_i^\\varN\\mod \\varN$. Verifier trusting prover on the non-interactive protocol:  $\\varverifier$ uses $\\rhovar_i$ values provided by $\\varprover$ instead of generating them: this is a high severity issue since the prover can trivially forge proofs (e.g., by sending $\\rhovar_i=1, \\sigmavar_i=1$). $\\varverifier$ does not validate $\\sigmavar_i$ as valid values modulo $\\varN$ (between 0 and $\\varN -1)$: this allows replaying the same proof with different values with $\\sigmavar_i + k\\varN$. $\\varverifier$ does not compare the number of received $\\sigmavar_i$ with $m$: this can lead to the prover bypassing proof verification by sending an empty list, or fewer than $m$ elements.   Replay attacks: After a non-interactive proof is public, it will always be valid and anyone could pretend to know how to prove the original statement. To prevent this, consider adding additional information to the generation of $\\rhovar_i$ values such as an ID of both the prover and the verifier, and a timestamp. The verifier must check the validity of these values when they verify the proof.  Auxiliary functions - $\\mathsf{gen}_\\rhovar$ #   Generate the $\\rhovar_i$ values with a standard nothing-up-my-sleeve construction in $\\z{\\varN}$, use binding parameters $\\{\\varN, i\\}$, bitsize of $|\\varN|$, and salt $\\mathsf{\u0026ldquo;squarefreeproof\u0026rdquo;}$. To prevent replay attacks consider including, in the binding parameters, ID\u0026rsquo;s unique to the prover and verifier.  Choice of security parameters $\\alpha$, $\\kappa$ #  The security of the protocol depends $\\alpha$ and $\\kappa$ which define the number of witnesses that $\\varprover$ has to give $\\varverifier$. The protocol achieves a statistical soundness error of $2^{-\\kappa}$, which means $\\varprover$ cannot cheat except with probability $2^{-\\kappa}$.\nParameter $\\alpha$ is tunable and controls proving and verification time. Higher $\\alpha$ values will generally decrease proving time and verification time, until some limit is reached and the verification time starts increasing.\nRecommended values for the security parameters are:\n $\\kappa = 128$ $\\alpha = 65537, 319567$ can be tried and the best performing one chosen.  These values yield $m$ values of\n $m(\\kappa=128, \\alpha=65537) = 8$ and $m(\\kappa=128, \\alpha=319567) = 7$.  "},{"id":8,"href":"/docs/zkdocs/security-of-zkps/","title":"Security of ZKPs","section":"Introduction","content":"Introduction #  Security of ZKPs and their implementations #  Here we present several security issues with implementations of zero-knowledge protocols, Fiat-Shamir transformations, and what can happen when interactive zero-knowledge proof systems are used in the context of malicious adversaries.\n  Using HVZKP in the wrong context  Potential attacks when honest verifier zero-knowledge proofs are used in the context of a malicious verifier.   "},{"id":9,"href":"/docs/zkdocs/zero-knowledge-protocols/product-primes/","title":"Number is product of two primes","section":"Zero-knowledge protocols","content":"Product of primes #  One way to prove that some number $\\varN$ is the product of two primes $\\varN = \\varp \\varq$ is by showing that:\n $\\varN$ is square-free $\\varN$ only has two divisors  If we only showed that $\\varN$ is square-free, then it could be of the form $\\varN = \\varp \\varq \\varr$. On the other hand, if we only proved that $\\varN$ has two divisors, it could be of the form $\\varN = \\varp^2\\varq$.\nWhen the primes are congruent with $3 \\; \\mathsf{mod}\\; 4$, we can show that $\\varN$ is the product of two primes much more efficiently with the Paillier-Blum modulus proof.\n  Number is square-free  Proves that a number is square-free.   Two prime divisors  Proves that a number has two prime divisors.   Product of two primes  Proves that a number is the product of two distinct primes: in parallel, run the square-freeness proof together with the two-prime-divisors proof.   Paillier-Blum Modulus  An efficient proof that shows a number is the product of two primes congruent with 3 mod 4.   "},{"id":10,"href":"/docs/zkdocs/protocol-primitives/","title":"Protocol primitives","section":"Introduction","content":"Introduction #  Protocol primitives #  In this section, we detail commonly used primitives in zero-knowledge protocols.\n  Random Sampling  In this section, we describe how to uniformly sample from different groups using rejection sampling.   Fiat-Shamir transformation  Here, we describe what the Fiat-Shamir transformation is, its goals, its pitfalls, and its different versions.   Nothing-up-my-sleeve constructions  Generic, honest, and deterministic method to sample elements.   Shamir\u0026#39;s Secret Sharing Scheme  An overview of Shamir\u0026rsquo;s Secret Sharing scheme and potential security pitfalls.   Feldman\u0026#39;s Verifiable Secret Sharing  A verifiable version of Shamir\u0026rsquo;s secret sharing scheme due to Feldman.   Alternative versions of Shamir\u0026#39;s Secret Sharing scheme  Secret sharing alternatives which do not hide the secret in the constant term of the polynomial.   "},{"id":11,"href":"/docs/zkdocs/zero-knowledge-protocols/product-primes/two-prime-divisors/","title":"Two prime divisors","section":"Number is product of two primes","content":"Number has exactly two prime divisors #  To prove that a number is the product of two distinct primes, one step is showing that the number only has two prime divisors, i.e., showing that $\\varN$ is not of the form $\\varN = pqr$.\nThis protocol allows to prove in zero-knowledge \u0026ndash;without revealing its factors\u0026ndash; that a number is in the set $$L_{ppp} = \\{\\varN \\in \\naturals : \\varN \\text{ is odd and has exactly two distinct prime divisors}\\}.$$\nGoal: $\\varprover$ convinces $\\varverifier$ that $\\varN$ only has two distinct prime divisors without revealing its factorization.   Public input: $\\varN\\in\\naturals$ Private input: $\\varprover$ knows the factorization of $\\varN = \\varp\\varq$ Security parameters: $\\kappa, m = \\ceil{\\kappa \\cdot 32 \\cdot \\ln(2)}$  The protocol works because an honest prover can calculate square-roots of arbitrary numbers in $\\z{\\varN}$.\nBoth parties have to agree on the security parameter $\\kappa$ prior to the execution of the protocol.\nInteractive protocol #  Security note: The protocol is zero-knowledge (does not reveal the factorization of $\\varN$) only when the verifier is honest and generates each $\\rhovar_i$ randomly. If the verifier choses these values maliciously they can recover the factorization of $\\varN$. If your attacker model takes this into consideration, use the non-interactive version. More details on Using HVZKP in the wrong context.  $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\bobwork{\\sampleSet{\\rhovar_i}{J_\\varN}, \\text{ for }i=1,\\ldots,m} \\bobalice{}{\\{\\rhovar_i\\}_{i=1}^m}{} \\alicework{\\sigmavar_i = \\begin{cases} \\sqrt{\\rhovar_i} \\mod \\varN \u0026\\text{ if }\\rhovar_i \\in QR_\\varN \\\\ 0 \u0026\\text{ otherwise} \\end{cases} } \\alicework{\\text{ for }i=1,\\ldots,m} \\alicebob{}{\\{\\sigmavar_i\\}_{i=1}^m}{} \\bobwork{\\varN \\gQ 1} \\bobwork{\\varN \\mod 2 \\equalQ 1} \\bobwork{\\mathsf{isPrime}(\\varN) \\equalQ false} \\bobwork{\\mathsf{isPrimePower}(\\varN) \\equalQ false} \\bobwork{\\gcd(\\varN, \\Pi_\\alpha) \\equalQ 1} \\bobwork{|\\{\\sigmavar_i \\text{ for }i=1,\\ldots,m| \\sigmavar_i \\neq 0\\}| \\gQ 3m/8} \\bobwork{\\text{if } \\sigmavar_i \\neq 0 \\text{ then }\\rhovar_i \\equalQ \\sigmavar_i^2 \\mod \\varN} \\end{array} $$ In this protocol we need to uniformly sample from the $J_\\varN$, the set of integers modulo $\\varN$ with Jacobi symbol $1$. The prover also needs to check membership of the $QR_\\varN$, the set of quadratic residues modulo $\\varN$. Both computations, the Jacobi symbol and quadratic residuosity, can be done efficiently.\n Non-interactive protocol #  The non-interactive version of the protocol replaces the verifier-side sampling of $\\rhovar_i$ and generates them using the $\\mathsf{gen}_\\rhovar$ function. The participants only exchange one message and this proof can be used in the context of malicious verifiers. $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\rhovar_i = \\mathsf{gen}_\\rhovar(J_\\varN, \\{\\varN,i, F\\})} \\alicework{\\sigmavar_i = \\begin{cases} \\sqrt{\\rhovar_i} \\mod \\varN \u0026\\text{ if }\\rhovar_i \\in QR_\\varN \\\\ 0 \u0026\\text{ otherwise} \\end{cases} } \\alicework{\\text{ for }i=1,\\ldots,m} \\alicebob{}{\\bunchi{\\sigmavar_i}, F}{} \\bobwork{\\varN \\gQ 1} \\bobwork{\\varN \\mod 2 \\equalQ 1} \\bobwork{\\mathsf{isPrime}(\\varN) \\equalQ false} \\bobwork{\\mathsf{isPrimePower}(\\varN) \\equalQ false} \\bobwork{\\gcd(\\varN, \\Pi_\\alpha) \\equalQ 1} \\bobwork{\\rhovar_i = \\mathsf{gen}_\\rhovar(J_\\varN, \\{\\varN,i, F\\})} \\bobwork{|\\{\\sigmavar_i \\text{ for }i=1,\\ldots,m| \\sigmavar_i \\neq 0\\}| \\gQ 3m/8} \\bobwork{\\text{if } \\sigmavar_i \\neq 0 \\text{ then }\\rhovar_i \\equalQ \\sigmavar_i^2 \\mod \\varN} \\end{array} $$ Security pitfalls #   Using the interactive protocol in a malicious verifier context: high severity issue which allows factoring $\\varN$; see Using HVZKP in the wrong context. Sampling $\\rhovar_i$ values uniformly and not using honest generation: high severity issue, allows $\\varprover$ to forge proofs by sampling $\\sampleSet{\\sigmavar_i}{\\z\\varN}$ and setting $\\rhovar_i = \\sigmavar_i^2\\mod \\varN$. Failing to include a fresh value in $\\mathsf{gen}_\\rhovar$: potential high severity issue since this means that all proofs for the same $\\varN$ will have the same $\\rhovar_i$; if the prover uses a probabilistic algorithm to compute square-roots, he can leak two different square-roots of the same value, allowing an attacker to factor $\\varN$ using the same attack as Using HVZKP in the wrong context. If the square-root algorithm always returns the same square-root for a given $\\rhovar_i$ this is not an issue. Verifier trusting prover on the non-interactive protocol:  $\\varverifier$ uses $\\rhovar_i$ values provided by $\\varprover$ instead of generating them: this is a high severity issue since the prover can trivially forge proofs (e.g., by sending $\\rhovar_i=1, \\sigmavar_i=1$). $\\varverifier$ does not validate $\\sigmavar_i$ as valid values modulo $\\varN$ (between 0 and $\\varN -1)$: this allows replaying the same proof with different values with $\\sigmavar_i + k\\varN$. $\\varverifier$ does not compare the number of received $\\sigmavar_i$ with $m$: this can lead to the prover bypassing proof verification by sending an empty list, or fewer than $m$ elements.   Replay attacks: After a non-interactive proof is public, it will always be valid and anyone could pretend to know how to prove it. To prevent this, consider adding additional information to the hash function such as an ID of both the prover and the verifier and a timestamp.  Choice of security parameters $\\kappa$ #  The protocol uses the security parameter $\\kappa$ to determine the number of exchanged elements.\nFor different $\\kappa$ values, we obtain\n $m(\\kappa=64) = 1420$ $m(\\kappa=128) = 2840$  Honest parameter generation $\\mathsf{gen}_\\rhovar$ #   Generate the $\\rhovar_i$ values with a standard nothing-up-my-sleeve construction in $J_{\\varN}$, use binding parameters $\\{\\varN, i, F\\}$, bitsize of $|\\varN|$, and salt $\\mathsf{\u0026ldquo;twoprimedivisorsproof\u0026rdquo;}$. To prevent replay attacks consider including, in the binding parameters, ID\u0026rsquo;s unique to the prover and verifier.  Auxiliary algorithms #    To calculate the Jacobi symbol use Algorithm 2.149 of the Handbook of Applied Cryptography.\n  To calculate square-roots modulo $\\varN$ use Algorithm 3.44 of the Handbook of Applied Cryptography.\n  To implement $\\mathsf{isPrimePower}$, a simple algorithm is here and also explained on page 3 of the AKS paper. Note 3.6 of the Handbook of Applied Cryptography also has a description.\n  Most libraries will have a primality testing routine for the $\\mathsf{isPrime}$ function.\n  "},{"id":12,"href":"/docs/zkdocs/protocol-primitives/nums/","title":"Nothing-up-my-sleeve constructions","section":"Protocol primitives","content":"Nothing-up-my-sleeve constructions #  Protocols often require using public but random group elements or alternative generators. If these were simply randomly sampled, other participants could be suspicious that the party did not honestly generate them.\nTo generate the elements you require:\n membership: know how to check membership in the sample space bit-size: know the bit-size of the elements binding parameters: the protocol\u0026rsquo;s public values other binding parameters like an index salt  Example: In the Short factoring proofs non-interactive protocol, we need to generate values $\\varz_i \\in \\zns{\\varN}$. Our ingredients are:\n membership: to check if an element $e$ is in $\\zns{\\varN}$, we check that $\\gcd(e, \\varN) = 1$ bit-size: the element bit-size will be $|\\varN|$ binding parameters: $\\varN$ and $i$ salt: the salt can be $\\mathsf{\u0026ldquo;shortfactoringproof\u0026rdquo;}$   The construction is generic: start a counter and sample an element with an extendible-output hash function over the binding parameters and the counter; if the generated element is in the sample space, we return it; otherwise, we increment the counter and sample again.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  DS = \u0026#39;|\u0026#39;  # Rejection sampling using a counter and binding parameters of the protocol def gen_element(sample_space_predicate, bitsize, param_list, salt):  counter = 0  while True:   # elements to hash  elements = param_list + [salt, counter]   # add each element\u0026#39;s length  to_hash = [len(s) + s for s in elements]   # domain separated elements  to_hash = DS + DS.join(to_hash)   # generate bitsize element with extendible-output hash function  e = hash_xof(to_hash, bitsize)   # check that e is in sample_space  if sample_space_predicate(e):  return e   # increment counter  counter += 1   Hash function choice #  The hash function used here must be an extendible-output function (XOF). These hash functions can generate an output of arbitrary length. We must use these functions since the elements we are sampling can have an arbitrary number of bits, and failing to achieve that size can cause security issues. An example is $\\mathsf{SHAKE256}$, which provides 256-bit security against collision attacks when at least 512 bits are sampled.\nAn alternative is using $\\mathsf{TupleHash}$ which does not require manually domain-separating the elements to be hashed.\n"},{"id":13,"href":"/docs/zkdocs/zero-knowledge-protocols/girault-identification/","title":"Girault's identification protocol","section":"Zero-knowledge protocols","content":"Girault\u0026rsquo;s identification protocol #  This scheme is a zero-knowledge proof for a discrete logarithm, like Schnorr\u0026rsquo;s protocol, but over a composite modulus instead of a prime modulus.\nGoal: $\\varprover$ convinces $\\varverifier$ that they know $\\varx$ such that $\\varh = \\varg^{-\\varx} \\mod \\varN$   Public input: $\\varh, \\varN$ and a high order generator $\\varg\\in \\zns{\\varN}$ Private input: $\\varprover$ knows the secret $\\varx\\in \\range{S}$ Security parameters: The parameters $k, k\u0026rsquo;, S$ and $R = 2^{k+k\u0026rsquo; + |S|}$.  Interactive protocol #  Security note: The interactive identification protocol assumes an honest verifier and should not be used in the context of malicious verifiers. A malicious verifier can send $\\vare = R$ and recover the secret $\\varx$ by dividing $\\varz$ by $\\vare$.  $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\varh = \\varg^{-\\varx} \\mod \\varN} \\alicework{\\sampleRange{\\varr}{R}} \\alicework{\\varu = \\varg^\\varr \\mod \\varN} \\alicebob{}{\\varu}{} \\bobwork{\\sampleRange{\\vare}{2^k}} \\bobalice{}{\\vare}{} \\alicework{\\varz = \\varr + \\varx\\cdot \\vare \\in \\naturals} \\alicebob{}{\\varz}{} \\bobwork{\\varu \\equalQ \\varg^{\\varz} \\cdot \\varh^\\vare \\mod \\varN} \\end{array} $$  Non-interactive protocol #  We obtain a non-interactive protocol using the Fiat-Shamir heuristic, where the prover creates the random $k$-bit challenge $\\vare$ using domain-separated hash function over the $\\{\\varg, \\varN, \\varh, \\varu\\}$ parameters. $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\varh = \\varg^{-\\varx} \\mod \\varN} \\alicework{\\sampleRange{\\varr}{R}} \\alicework{\\varu = \\varg^\\varr \\mod \\varN} \\alicework{\\vare = \\hashbit{\\varg, \\varN, \\varh, \\varu}{k}} \\alicework{\\varz = \\varr + \\varx\\cdot \\vare \\in \\naturals} \\alicebob{}{\\varu, \\vare, \\varz}{} \\bobwork{\\vare \\equalQ \\hashbit{\\varg, \\varN, \\varh, \\varu}{k}} \\bobwork{\\varu \\equalQ \\varg^{\\varz} \\cdot \\varh^\\vare \\mod \\varN} \\end{array} $$ Security pitfalls #   Parameter choice: Implementers must pay special attention to the choice of parameter values, in particular the relation between $2^k$ and $R$. If these were of similar size, since $\\varz$ is computed over the naturals, $\\varx$ would be approximately $\\lfloor \\varz/\\vare\\rfloor$. Using the interactive protocol in a malicious verifier context: high severity issue which allows recovering the secret $\\varx$; see Using HVZKP in the wrong context. Verifier trusting prover on the non-interactive protocol:  $\\varverifier$ uses a $\\varg$ value provided by $\\varprover$ instead of using the standard generator: this is a high severity issue since the prover can trivially forge proofs (e.g., by sending $\\varu=0, \\varg=0$). $\\varverifier$ does not validate $\\varu,\\varh$ as valid elements of $\\zns{\\varN}$ (between 1 and $\\varN-1$ and with $\\gcd(k, \\varN) = 1$): this allows replaying the same proof with different values adding multiples of $\\varN$.   Replay attacks: After a non-interactive proof is public, it will always be valid, and anyone could pretend to know how to prove the original statement. To prevent this, consider adding additional information to the computation of the hash function: values such as an ID unique to the prover and verifier, and a timestamp. The verifier must use these values and check their validity to verify the proof.  Choice of parameter values #   $|\\varN| = 2048$ $S = 2^{256}$ $k,k\u0026rsquo; = 128$  Auxiliary procedures #     Hash function $\\hashbit{\\cdot}{k}$: this hash function should be domain-separated and have a specific output size of $k$-bits. Using $\\mathsf{TupleHash}$ satisfies these restrictions.    "},{"id":14,"href":"/docs/zkdocs/zero-knowledge-protocols/product-primes/product-of-two-primes/","title":"Product of two primes","section":"Number is product of two primes","content":"Number is the product of two primes #  To show that a number is the product of two distinct primes, we make use of the previous protocols to show that:\n $\\varN$ is square-free $\\varN$ only has two divisors  Formally, we show that $\\varN$ is in the set $$L_{pp} = \\{N \\in \\naturals | N \\text{ is odd and is the product of two distinct primes}\\} = L_{ppp} \\cap \\sqfree.$$ For this, we run the protocols from Square-free and Two prime divisors in parallel for the same $N$.\nGoal: $\\varprover$ convinces $\\varverifier$ that $\\varN$ is the product of two distinct primes without revealing its factorization.   Public input: $\\varN\\in\\naturals$ Private input: $\\varprover$ knows the factorization of $\\varN = \\varp\\varq$ Security parameters: $\\alpha, \\kappa, m_1 = \\ceil{\\kappa/ \\log_2 \\alpha}$, $m_2 = \\ceil{\\kappa \\cdot 32 \\cdot \\ln(2)}$  We only present the non-interactive version of this protocol, suitable to use in the context of malicious verifiers.\nNon-interactive protocol #  $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\rhovar_i = \\mathsf{gen}_\\rhovar(\\z{\\varN}, \\{\\varN,i\\})} \\alicework{\\sigmavar_i = (\\rhovar_i)^{\\varN^{-1}\\mod \\varphi(\\varN)} \\mod \\varN,} \\alicework{\\text{ for }i=1,\\ldots,m_1} \\aliceseparator \\alicework{\\thetavar_i = \\mathsf{gen}_\\rhovar(J_\\varN, \\{\\varN, m_1 + i, F\\})} \\alicework{\\muvar_i = \\begin{cases} \\sqrt{\\thetavar_i} \\mod \\varN \u0026\\text{ if }\\thetavar_i \\in QR_\\varN \\\\ 0 \u0026\\text{ otherwise} \\end{cases} } \\alicework{\\text{ for }i=1,\\ldots,m_2} \\alicebob{}{\\{\\sigmavar_i\\}_{i=1}^{m_1}, \\{\\muvar_i\\}_{i=1}^{m_2}, F}{} \\bobwork{\\varN \\gQ 1} \\bobwork{\\varN \\mod 2 \\equalQ 1} \\bobwork{\\mathsf{isPrime}(\\varN) \\equalQ false} \\bobwork{\\mathsf{isPrimePower}(\\varN) \\equalQ false} \\bobwork{\\gcd(\\varN, \\Pi_\\alpha) \\equalQ 1} \\bobwork{\\sigmavar_i \\gQ 0,} \\bobwork{\\rhovar_i = \\mathsf{gen}_\\rhovar(\\z{\\varN}, \\{\\varN,i\\})} \\bobwork{\\rhovar_i \\equalQ \\sigmavar_i^\\varN \\mod \\varN,} \\bobwork{\\text{ for }i=1,\\ldots,m_1} \\bobseparator \\bobwork{\\thetavar_i = \\mathsf{gen}_\\rhovar(J_\\varN, \\{\\varN, m_1 + i, F\\})} \\bobwork{|\\{\\muvar_i \\text{ for }i=1,\\ldots,m| \\muvar_i \\neq 0\\}| \\gQ 3m_2/8} \\bobwork{\\text{if } \\muvar_i \\neq 0 \\text{ then }\\thetavar_i \\equalQ \\muvar_i^2 \\mod \\varN} \\bobwork{\\text{ for }i=1,\\ldots,m_2} \\end{array} $$ Security parameters #   $\\kappa = 128$ $m_1(\\kappa=128, \\alpha=65537) = 8$ $m_2(\\kappa=128) = 2840$  Security pitfalls #  This protocol suffers from the same pitfalls as the Square-free and Two prime divisors protocols. We include them here for clarity:\n Sampling the $\\rhovar_i$ or $\\thetavar_i$ values uniformly and not using honest generation: high severity issue that allows $\\varprover$ to forge proofs by sampling $\\sampleSet{\\sigmavar_i,\\muvar_i}{\\z\\varN}$, and setting $\\rhovar_i = \\sigmavar_i^\\varN\\mod \\varN$ and $\\thetavar_i = \\muvar_i^2\\mod \\varN$ . Failing to include a fresh value in $\\mathsf{gen}_\\rhovar$ to generate $\\thetavar_i$: potential high severity issue since this means that all proofs for the same $\\varN$ will have the same $\\thetavar_i$ values; if the prover uses a probabilistic algorithm to compute square-roots, he can leak two different square-roots of the same value, allowing an attacker to factor $\\varN$ using the same attack as Using HVZKP in the wrong context. If the square-root algorithm always returns the same square-root for a given $\\rhovar_i$ this is not an issue. Verifier trusting prover on the non-interactive protocol:  $\\varverifier$ uses $\\rhovar_i$ or $\\thetavar_i$ values provided by $\\varprover$ instead of generating them: this is a high severity issue since the prover can trivially forge proofs (e.g., by sending $\\rhovar_i=1, \\sigmavar_i=1$ and $\\thetavar_i = 1, \\muvar_i=1$). $\\varverifier$ does not validate $\\sigmavar_i$, $\\muvar_i$ as valid values modulo $\\varN$ (between 0 and $\\varN -1)$: this allows replaying the same proof with different values with $\\sigmavar_i + k\\varN$, $\\muvar_i + k\u0026rsquo;\\varN$. $\\varverifier$ does not compare the number of received $\\sigmavar_i$ with $m_1$ and $\\muvar_i$ with $m_2$: this can lead to the prover bypassing proof verification by sending an empty list, or fewer than $m_1$ or $m_2$ elements.   Replay attacks: After a non-interactive proof is public, it will always be valid and anyone could pretend to know how to prove the original statement. To prevent this, consider adding additional information to the generation of $\\rhovar_i$ and $\\thetavar_i$ values such as an ID of both the prover and the verifier, and a timestamp. The verifier must check the validity of these values when they verify the proof.  Performance considerations #  For the desired security level of $\\kappa=128$, we need to generate 2840 $\\muvar_i$ elements. Because of this, this proof system can be very computationally expensive. If this dramatically affects the performance of your protocol, and your $\\varN$ is the product of two primes congruent with $3\\mod 4$, we recommend using an alternative proof system, the Paillier-Blum modulus proof.\nHonest parameter generation $\\mathsf{gen}_\\rhovar$ #   Generate the $\\rhovar_i$ and $\\thetavar_i$ values with a standard nothing-up-my-sleeve construction:  $\\rhovar_i$ in $\\z{\\varN}$, use binding parameters $\\{\\varN, i\\}$, bitsize of $|\\varN|$, and salt $\\mathsf{\u0026ldquo;productoftwoprimesproof\u0026rdquo;}$. $\\thetavar_i$ in $J_{\\varN}$, use binding parameters $\\{\\varN, i, F\\}$, bitsize of $|\\varN|$, and salt $\\mathsf{\u0026ldquo;productoftwoprimesproof\u0026rdquo;}$. $F$ should be a fresh value unique to the current proof.   To prevent replay attacks consider including, in the binding parameters, ID\u0026rsquo;s unique to the prover and verifier.  Auxiliary algorithms #    To calculate the Jacobi symbol use Algorithm 2.149 of the Handbook of Applied Cryptography.\n  To calculate square-roots modulo $\\varN$ use Algorithm 3.44 of the Handbook of Applied Cryptography.\n  To implement $\\mathsf{isPrimePower}$, a simple algorithm is here and also explained on page 3 of the AKS paper. Note 3.6 of the Handbook of Applied Cryptography also has a description.\n  Most libraries will have a primality testing routine for the $\\mathsf{isPrime}$ function.\n  "},{"id":15,"href":"/docs/zkdocs/security-of-zkps/when-to-use-hvzk/","title":"Using HVZKP in the wrong context","section":"Security of ZKPs","content":"Using HVZKP in the wrong context #  Honest verifier zero-knowledge proofs (HVZKP) assume \u0026ndash;yes, you guessed it\u0026ndash; an honest verifier! This means that in the presence of malicious verifiers, non-interactive protocols should always be used. These also exchange fewer messages between prover and verifier.\nA malicious verifier can employ different attacks depending on the proof system. Here, we will present attacks for the Short factoring proofs and the Two prime divisors proof.\nThe case of the Short-Factoring-Proofs #  Recall that in Short factoring proofs the prover shows that they know $\\varphi(\\varN)$ in the style of Girault\u0026rsquo;s scheme. $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleRange{\\varr}{A}} \\alicework{\\varx_i = \\varz_i^\\varr \\mod \\varN} \\alicework{\\forb} \\alicebob{}{\\bunch{\\varx}}{} \\bobwork{\\sampleRange{\\vare}{B}} \\bobalice{}{\\vare}{} \\alicework{\\vary = \\varr + (\\varN - \\varphi(\\varN))\\cdot \\vare \\in \\naturals} \\alicebob{}{\\vary}{} \\bobwork{\\vary \\inQ \\range{A}} \\bobwork{\\varx_i \\equalQ \\varz_i^{\\vary- \\vare\\cdot\\varN} \\mod \\varN \\forb} \\end{array} $$ After the initial commit, the verifier responds with a challenge $e$ supposedly sampled from $\\range{B}$. However, being malicious, the verifier choses $\\vare=A$, the maximum value that $\\varr$ can be. So, that after receiving $\\vary = \\varr + (\\varN - \\varphi(\\varN))\\cdot \\vare$, they can compute $\\varN - \\vary//\\vare$ which will reveal $\\varphi(\\varN)$.\nThe case of the Two-Prime-Divisor proof #  In the Two prime divisors proof, the prover has no way of checking if the verifier is trying to attack them. Recall the beginning of the protocol that the verifier chooses $\\rhovar_i$ values: $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\bobwork{\\sampleSet{\\rhovar_i}{J_\\varN}, \\text{ for }i=1,\\ldots,m} \\bobalice{}{\\{\\rhovar_i\\}_{i=1}^m}{} \\alicework{\\sigmavar_i = \\begin{cases} \\sqrt{\\rhovar_i} \\mod \\varN \u0026\\text{ if }\\rhovar_i \\in QR_\\varN \\\\ 0 \u0026\\text{ otherwise} \\end{cases} } \\alicework{\\text{ for }i=1,\\ldots,m} \\alicebob{}{\\{\\sigmavar_i\\}_{i=1}^m}{} \\end{array} $$ Then, the verifier computes the square-roots of these values! It is known that factoring and computing modular square-roots are equivalent [HOC - Fact 3.46].\nAn attacker can:\n select random numbers $r_i$ send their square $r^2_i \\mod \\varN$ to the prover,  The prover will compute their square roots, $\\sigma_i$ which can be different than $\\pm \\varr_i$ since there are four different square-roots modulo $\\varN = p q$. When $\\sigma_i\\neq \\pm \\varr_i$, computing $\\gcd (\\varN, \\sigma_i - r_i)$ will reveal one of the factors of $\\varN$. This is because\n$\\begin{align*} \\sigma_i^2 \u0026amp;\\equiv r_i^2 \\mod \\varN \\\\ (\\sigma_i^2 - r_i^2) \u0026amp;\\equiv 0 \\mod \\varN \\\\ (\\sigma_i - r_i)(\\sigma_i + r_i) \u0026amp;\\equiv 0 \\mod \\varN \\end{align*}$\n"},{"id":16,"href":"/docs/zkdocs/zero-knowledge-protocols/product-primes/paillier_blum_modulus/","title":"Paillier-Blum Modulus","section":"Number is product of two primes","content":"Paillier-Blum Modulus #  This protocol allows the prover to show that a public modulus is the product of two $3 \\; \\mathsf{mod}\\; 4$ prime numbers. Since safe-primes \u0026ndash; primes of the form $p = 2q + 1$ where $q$ is also prime \u0026ndash; are congruent with $3\\; \\mathsf{mod}\\; 4$, this proof system can be used in those cases. Similar to the proof for Product of two primes, this system also uses the proof of Square freeness. This proof system is also much more efficient than the one for the Product of two primes.\nGoal: $\\varprover$ convinces $\\varverifier$ that $\\varN$ is the product of two primes congruent with $3\\; \\mathsf{mod}\\; 4$, and that $\\gcd(\\varN, \\varphi(\\varN)) = 1$, without revealing its factorization.   Public input: modulus $\\varN$ Private input: $\\varprover$ knows $p,q$ such that $\\varN = p q$. These are primes congruent with $3\\; \\mathsf{mod}\\; 4$. Security parameters: $m$ to achieve a cheating probability of $2^{-m}$  Interactive protocol #  Security note: The protocol is zero-knowledge (does not reveal the factorization of $\\varN$) only when the verifier is honest and randomly generates each $\\vary_i$. If the verifier chooses these values maliciously, they can recover the factorization of $\\varN$. If your attacker model considers this, use the non-interactive version. More details on Using HVZKP in the wrong context.  $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleN{\\varw}{\\varN} \\text{ with }J(\\varw, \\varN) = -1} \\alicebob{}{\\varw}{} \\bobwork{\\sampleNs{\\vary_i}{\\varN} } \\bobalice{}{\\bunch{\\vary}}{} \\alicework{\\varz_i = \\vary_i^{\\varN^{-1} \\mod \\varphi ( \\varN )}} \\alicework{\\varx_i = \\sqrt[4]{\\vary_i'} \\mod \\varN} \\alicework{\\text{where } \\vary_i' = (-1)^{\\vara_i} \\varw^{\\varb_i} \\vary_i \\in QR_\\varN} \\alicework{\\text{and } \\vara_i, \\varb_i \\in \\{0, 1\\}\\enspace\\;\\;} \\alicework{\\text{ for }i=1,\\ldots,m} \\alicebob{}{\\bunchi{(\\varx_i, \\vara_i, \\varb_i), \\varz_i}}{} \\bobwork{\\varN \\gQ 1} \\bobwork{\\varN \\mod 2 \\equalQ 1} \\bobwork{\\mathsf{isPrime}(\\varN) \\equalQ false} \\bobwork{ \\varz_i ^\\varN \\equalQ \\vary_i \\mod \\varN } \\bobwork{\\vara_i, \\varb_i \\inQ \\{0, 1\\} } \\bobwork{ \\varx_i ^4 \\equalQ (-1)^{\\vara_i} \\varw^{\\varb_i} \\vary_i \\mod \\varN } \\bobwork{\\text{ for }i=1,\\ldots,m} \\end{array} $$  Non-interactive protocol #  The non-interactive version of the protocol replaces the verifier-side sampling of $\\vary_i$ and generates them using the $\\mathsf{gen}_\\vary$ function. The participants only exchange one message and this proof can be used in the context of malicious verifiers.\n$$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleN{\\varw}{\\varN} \\text{ with }J(\\varw, \\varN) = -1} \\alicework{\\vary_i = \\mathsf{gen}_\\vary(\\zns{\\varN}, \\{\\varN, \\varw, i\\})} \\alicework{\\varz_i = \\vary_i^{\\varN^{-1} \\mod \\varphi ( \\varN )}} \\alicework{\\varx_i = \\sqrt[4]{\\vary_i'} \\mod \\varN} \\alicework{\\text{where } \\vary_i' = (-1)^{\\vara_i} \\varw^{\\varb_i} \\vary_i \\in QR_\\varN} \\alicework{\\text{and } \\vara_i, \\varb_i \\in \\{0, 1\\}\\enspace\\;\\;} \\alicework{\\text{ for }i=1,\\ldots,m} \\alicebob{}{\\varw, \\bunchi{(\\varx_i, \\vara_i, \\varb_i), \\varz_i}}{} \\bobwork{\\varN \\gQ 1} \\bobwork{\\varN \\mod 2 \\equalQ 1} \\bobwork{\\mathsf{isPrime}(\\varN) \\equalQ false} \\bobwork{J(\\varw, \\varN) \\equalQ -1} \\bobwork{\\vary_i = \\mathsf{gen}_\\vary(\\zns{\\varN}, \\{\\varN, \\varw, i\\})} \\bobwork{ \\varz_i ^\\varN \\equalQ \\vary_i \\mod \\varN } \\bobwork{\\vara_i, \\varb_i \\inQ \\{0, 1\\} } \\bobwork{ \\varx_i ^4 \\equalQ (-1)^{\\vara_i} \\varw^{\\varb_i} \\vary_i \\mod \\varN } \\bobwork{\\text{ for }i=1,\\ldots,m} \\end{array} $$ Security pitfalls #   Using the interactive protocol in a malicious verifier context: high severity issue which allows factoring the modulus $\\varN$; see Using HVZKP in the wrong context. Not checking that $\\varN \\mod 2 \\equalQ 1$ and $\\varN \\gQ 1$ before computing the Jacobi symbol $J(\\varw, \\varN)$: the Jacobi symbol is only defined when $\\varN$ is an odd positive integer. Failing to verify this might lead to a program panic, as in the Go library. Verifier trusting prover on the non-interactive protocol:  $\\varverifier$ does not check that $J(\\varw, \\varN) = -1$: high severity issue since this allows $\\varprover$ to submit a proof forgery with $\\varw = 0$ and $\\varx_i = 0$.   $\\varverifier$ uses $\\vary_i$ values provided by $\\varprover$ instead of generating them: high severity issue since the prover can trivially forge proofs (e.g., by sending $\\rhovar_i=1, \\sigmavar_i=1$). $\\varverifier$ does not validate $\\varw, \\varz_i, \\varx_i$ as valid values modulo $\\varN$ (between 0 and $\\varN -1)$: this allows replaying the same proof with different values with $\\varz_i + k\\varN$. $\\varverifier$ does not compare the number of received tuples $(\\varx_i, \\vara_i, \\varb_i), \\varz_i$ with $m$: this can lead to the prover bypassing proof verification by sending an empty list, or fewer than $m$ elements.   Reusing the same $\\varw$ for further proofs of $\\varN$: reusing the same $\\varw$ value means that for a fixed $\\varN$, the $\\vary_i$ values will be the same; if the algorithm that computes the fourth-root is probabilistic, it can reveal different fourth-roots for the same value $\\vary_i\u0026rsquo;$, allowing an attacker to factor $\\varN$. Solve this in one of two ways: either add a fresh value to the parameters of $\\mathsf{gen}_\\vary$ and share it with $\\varverifier$, or ensure that you deterministically compute the fourth-roots. Replay attacks: After a non-interactive proof is public, it will always be valid, and anyone could pretend to know how to prove the original statement. To prevent this, consider adding additional information to the generation of $\\vary_i$ values, such as an ID of the prover and the verifier and a timestamp. The verifier must check the validity of these values when they verify the proof.  Choice of security parameters #  To achieve a safe security level, choose:\n $|\\varN| = 2048$ $m = 80$.  Honest parameter generation $\\mathsf{gen}_\\vary$ #   Generate the $\\vary_i$ values with a standard nothing-up-my-sleeve construction in $\\zns{\\varN}$, use binding parameters $\\{\\varN, \\varw, i\\}$, bitsize of $|\\varN|$, and salt $\\mathsf{\u0026ldquo;paillierblumproof\u0026rdquo;}$. To prevent replay attacks consider including, in the binding parameters, ID\u0026rsquo;s unique to the prover and verifier.  Auxiliary algorithms #   The function $J(\\varw, \\varN)$ is the Jacobi symbol of $\\varw$ modulo $\\varN$. To implement it use Algorithm 2.149 of the Handbook of Applied Cryptography. Compute modular fourth-roots using [HOC - Fact 2.160]: if $x$ is a quadratic residue modulo $\\varN = p q$ (and $p,q$ are $3\\mod 4$) then $\\sqrt[4]{x} = x^{(\\varphi + 4)/8} \\mod \\varN$, where $\\varphi = (p-1)\\cdot(q-1)$. The prover has to check if an element is a quadratic residue modulo $\\varN$. To do this, use [HOC - Fact 2.137]: $x$ is a quadratic residue modulo $\\varN = pq$ if and only if it is a quadratic residue modulo $p$ and modulo $q$. A number $x$ is a quadratic residue modulo a prime $p$, if $x^{(p-1)/2} = 1$. Thus, $x$ is a quadratic residue modulo $\\varN = pq$ if and only if $x^{(p-1)/2} = 1$ and $x^{(q-1)/2} = 1$. Most libraries will have a primality testing routine for the $\\mathsf{isPrime}$ function.  "},{"id":17,"href":"/docs/zkdocs/zero-knowledge-protocols/short-factoring-proofs/","title":"Short factoring proofs","section":"Zero-knowledge protocols","content":"Short factoring proofs #  This system proves knowledge of the factorization of an integer $\\varN$. Unlike Product of two primes, this is not a proof that $\\varN$ has two prime factors, only that the prover knows its factorization! This protocol is not easy to implement securely, so we recommend special attention to sections Choice of security parameters and Security pitfalls.\nGoal: $\\varprover$ convinces $\\varverifier$ that they know the factorization of $\\varN$ without revealing it.   Public input: An integer $\\varN$ Private input: $\\varprover$ knows the factorization of $\\varN =\\prod_i p_i^{e_i}$ Security parameters: The parameters $A, B, \\ell, m$, and $K$ all depend on $k$ and the bit-size of $\\varN$.  Vanilla interactive protocol #  Note: This version assumes that $\\varverifier$ is honest. A dishonest one would send $\\vare$ with similar size to $B$ and factor $\\varN$ using this attack.  The following diagram shows one of the protocol\u0026rsquo;s $\\ell$ iterations. $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleRange{\\varr}{A}} \\alicework{\\varz_i = \\mathsf{gen}_\\varz(\\zns{\\varN}, \\{\\varN, i\\})} \\alicework{\\varx_i = \\varz_i^\\varr \\mod \\varN} \\alicework{\\forb} \\alicebob{}{\\bunch{\\varx}, \\bunch{\\varz}}{} \\bobwork{\\sampleRange{\\vare}{B}} \\bobalice{}{\\vare}{} \\alicework{\\vary = \\varr + (\\varN - \\varphi(\\varN))\\cdot \\vare \\in \\naturals} \\alicebob{}{\\vary}{} \\bobwork{\\vary \\inQ \\range{A}} \\bobwork{\\varx_i \\equalQ \\varz_i^{\\vary- \\vare\\cdot\\varN} \\mod \\varN \\forb} \\end{array} $$  Improved interactive protocol #  Note: This version assumes that $\\varverifier$ is honest. A dishonest one would send $\\vare$ with similar size to $B$ and factor $\\varN$ using this attack.  $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleRange{\\varr}{A}} \\alicework{\\varz_i = \\mathsf{gen}_\\varz(\\zns{\\varN}, \\{\\varN, i\\})} \\alicework{\\varX = \\hash{\\bunchi{\\varz_i^\\varr \\mod \\varN}}} \\alicebob{}{\\varX, \\bunch{\\varz}}{} \\bobwork{\\sampleRange{\\vare}{B}} \\bobalice{}{\\vare}{} \\alicework{\\vary = \\varr + (\\varN - \\varphi(\\varN))\\cdot \\vare \\in \\naturals} \\alicebob{}{\\vary}{} \\bobwork{\\vary \\inQ \\range{A}} \\bobwork{\\varX \\equalQ \\hash{\\bunchi{\\varz_i^{\\vary- \\vare\\cdot\\varN} \\mod \\varN}}} \\end{array} $$  Non-interactive protocol #  We use the Fiat-Shamir heuristic, and the prover creates $\\vare$ using a $|B|$-bit sized hash function $\\hashbit{\\cdot}{|B|}$ and past public values. $$ \\begin{array}{c} \\work{\\varprover}{\\varverifier} \\alicework{\\sampleRange{\\varr}{A}} \\alicework{\\varz_i = \\mathsf{gen}_\\varz(\\zns{\\varN}, \\{\\varN, i\\})} \\alicework{\\varX = \\hash{\\bunchi{\\varz_i^\\varr \\mod \\varN}}} \\alicework{\\vare = \\hashbit{\\varN, \\bunch{\\varz},\\varX}{|B|}} \\alicework{\\vary = \\varr + (\\varN - \\varphi(\\varN))\\cdot \\vare \\in \\naturals} \\alicebob{}{\\vare, \\vary, \\varX}{} \\bobwork{\\vary \\inQ \\range{A}} \\bobwork{\\varz_i = \\mathsf{gen}_\\varz(\\zns{\\varN}, \\{\\varN, i\\})} \\bobwork{\\vare = \\hashbit{\\varN, \\bunch{\\varz},\\varX}{|B|}} \\bobwork{\\varX \\equalQ \\hash{\\bunchi{\\varz_i^{\\vary- \\vare\\cdot\\varN} \\mod \\varN}}} \\end{array} $$ Choice of security parameters #  We detail the choice of security parameters based on the bit-size of $\\varN$:\n $k$ \u0026ndash; the security parameter; the cheating probability of the protocol is $2^{-k}$. Choose 80, 128 or 256. $B$ and $\\ell$ \u0026ndash; the size of the challenge space and number of iterations; $B$ and $\\ell$ should satisfy $\\ell\\cdot \\log B = \\theta(k)$, so chose $\\ell=1$ and $B=2^k$ in the non-interactive protocol. $A$ \u0026ndash; the size of the commit space; $A$ must be smaller than $\\varN$ and satisfy $(\\varN - \\varphi(\\varN) ) \\ell B \\ll A \u0026lt; \\varN$. If you are sure that public moduli are of a fixed size \u0026ndash;like $|\\varN| = 2048$\u0026ndash; chose $A=2^{|\\varN|}$. If the public modulus can have smaller bit-size but never below $|\\varN| - 4$, chose $A=2^{|\\varN| - 4}$.  Security pitfalls #    The two interactive protocols assume an honest verifier. To use this protocol in the context of malicious verifiers, use the non-interactive version. See Using HVZKP in the wrong context.\n  Implementers of this proof system need to carefully choose the security parameters since failing to do it correctly leaks $\\varphi(\\varN)$: Consider the example where $\\varN$ is 2048 bits, the product of two 1024 bit primes. $\\varprover$ computes over $\\naturals$ the value $$\\vary = \\varr + (\\varN - \\varphi(\\varN))\\cdot \\vare$$ where $\\sampleRange{\\varr}{A}$ and $\\sampleRange{\\vare}{B}$. If $A$ and $B$ have similar size then $\\frac{r}{e}$ will be very small and $\\varverifier$ can compute $$-\\left\\lfloor \\frac{\\vary}{e} \\right \\rfloor + \\varN = \\left\\lfloor \\frac{r}{e} \\right \\rfloor + \\varphi (\\varN) \\approx \\varphi(\\varN) \\enspace ,$$ recovering $\\varphi(\\varN)$.\nA variant of this attack happens when $|\\frac{r}{e}| \u0026lt; \\frac{|\\varphi(\\varN)|}{4}$: in this case, a quarter of the least significant bits of $\\varphi(\\varN)$ are unknown, but this still allows an attacker to factor $\\varN$ using Coppersmith\u0026rsquo;s attack.\n   Using high security parameters with small modulus allows proof forgery: the security parameters $A=2^{2048}$, $B=2^{128}$ are configured to be used with modulus of size 2048 but the verification routine does not check the size of the modulus. A dishonest prover can send a proof of knowledge for a 1024 modulus and $$\\vary = \\varN \\cdot \\vare$$ will still be in the set $\\range{A}$ since $\\varN\\cdot \\vare \u0026lt; 2^{1025 + 129} \u0026lt; 2^{2048} = A$.\n  Verifier trusting prover on the non-interactive protocol: The $\\varverifier$ does not generate the $\\varz_i$ values and parses them from the proof without proper validation. The $\\varz_i$ values should be generated as described here. Failing to do so, and not checking that $\\varz_i\\in\\zns{\\varN}$, $\\varz_i \\mod \\varN \\not\\in \\{ -1 , 0, 1\\}$ leads to trivial proofs: when $\\varz_i \\equiv -1, 0, 1 \\mod \\varN$, all proofs are valid as long as $y\\in \\range{A}$.\n  Weak Fiat-Shamir transformation: In the non-interactive protocol, it is a common mistake to not include all values in the hash computation $\\hashbit{\\varN, \\bunch{\\varz},\\varX}{|B|}$. If any of these values are not included in this computation, it could lead to a high severity issue where the prover can forge proofs. See Fiat-Shamir transformation for more details.\n   Replay attacks: After a non-interactive proof is public, it will always be valid, and anyone could pretend to know how to prove it. To prevent this, consider adding additional information to the generation of the $\\varz$ values, such as an ID of the prover and the verifier and a timestamp. The verifier must check the validity of these values when they verify the proof.  Honest parameter generation $\\mathsf{gen}_\\varz$ #   Generate the $\\varz_i$ values with a standard nothing-up-my-sleeve construction in $\\zns{\\varN}$, use binding parameters $\\{\\varN, i\\}$, bitsize of $|\\varN|$, and salt $\\mathsf{\u0026ldquo;shortfactoringproofs\u0026rdquo;}$. To prevent replay attacks consider including, in the binding parameters, ID\u0026rsquo;s unique to the prover and verifier.  Auxiliary procedures #   Hash function $\\hashbit{\\cdot}{|B|}$: this hash function should be domain-separated and have a specific output size of $|B|$-bits. $\\mathsf{TupleHash}$ satisfies these restrictions.  "},{"id":18,"href":"/docs/zkdocs/protocol-primitives/shamir/","title":"Shamir's Secret Sharing Scheme","section":"Protocol primitives","content":"Shamirâ€™s Secret Sharing Scheme #  Shamir\u0026rsquo;s Secret Sharing Scheme is a way of splitting a secret value $S$ into $n$ \u0026ldquo;pieces\u0026rdquo; (or \u0026ldquo;shares\u0026rdquo;) in such a way that any combination of $k$ pieces can be used to recover $S$, but any $k-1$ or fewer pieces provide no information about $S$.\nOverview of Secret Sharing #  Shamir\u0026rsquo;s Secret Sharing Scheme relies on a very useful property of polynomials: any degree-$k$ polynomial can be uniquely identified by any set of $k+1$ distinct points. Two points define a line; three points define a parabola. However, with fewer than $k+1$ distinct points, no further information can be gained about the polynomial.\nThis leads directly to Shamir\u0026rsquo;s approach: encode a secret $S$ into a polynomial over a finite field, and distribute points on the polynomial as shares.\nSplitting $S$ #  Given a secret $S$, a number of desired shares $n$, and a threshold $k$, splitting $S$ comes down to two steps:\n encode $S$ into a secret polynomial $f\\left(x\\right)$ of degree $k-1$ over a finite field $\\field{p}$ generate distinct shares $\\left(x_{i}, f(x_i)\\right)$  Encoding $S$ in a Polynomial #  Shamir proposed a straightforward method for encoding secrets into polynomials: set the constant term of random polynomial to the secret $S$, and select all other coefficients uniformly at random. For a degree-$(k-1)$ polynomial, there would be $k-1$ random coefficients $r_i$, and the constant coefficient of $S$: $$f(x) = S + r_1 x + \\ldots + r_{k-1} x^{k-1} \\enspace.$$\nExample: We want to share our secret number 42 with three players so that any two of them can recover it. We define the degree-1 polynomial over $\\field{73}$ as $$f(x) = 42 + 13 \\cdot x \\enspace,$$ where 13 was randomly sampled over $\\field{73}$. We evaluate the polynomial at different points obtaining the shares $(x_i, f(x_i))$. Then, we can share 1 point of the coefficient to the three players, each getting one of $(1, 55), (2, 68), (3, 8)$. Since the polynomial is a line, any two of them could meet and recover the secret value 42!  This choice has the advantage of relative simplicity; there is no need to use oddball sampling techniques to select the coefficients of $f\\left(x\\right)$.\nA Note on Selecting $p$ #  In the general case, the specific prime $p$ does not matter much. Shamir\u0026rsquo;s original paper proposed using 16-bit primes (the largest of which would be $p=2^{16}-15=65521$) for performance reasons. By limiting intermediate results to 32 bits, multi-precision arithmetic routines could be avoided on any 32-bit processor. Large secrets could be broken into blocks of 16 bits or less and shared with distinct polynomials. One limitation imposed by such a small $p$ is that only about 65000 distinct shares can be generated.\nIn practice, $p$ should be reasonably large. Breaking $S$ into multiple parts introduces complexity and opportunities for malicious actors. Also, in some verifiable secret sharing schemes, a large $p$ is needed to prevent discrete log attacks.\nGenerating the Shares #  Shares $s_{1},s_{2},\\ldots,s_{n}$ of $S$ are ordered pairs $\\left(x_{i}, f\\left(x_{i}\\right)\\right)$. The $x_{i}$ values can be picked in several ways, but a counter starting in 1 is the most common method.\nRecovering $S$ #  The most common and direct method of recovering $S$ from the shares $s_{1},\\ldots,s_{k}$ is to evaluate $f\\left(0\\right)=S$ using Lagrange interpolation. It allows computing $f\\left(t\\right)$ for any $t\\in\\field{p}$ using the formula below:\n$$f\\left(t\\right) = \\displaystyle\\sum_{j=1}^{k}{y_{j}\\left(\\displaystyle\\prod_{\\begin{smallmatrix}1\\leq m\\leq k\\\\ m\\neq j\\end{smallmatrix}}{\\frac{t-x_m}{x_j - x_m}}\\right)}$$\nThe $t=0$ case slightly simplifies the product. Each product term can also be precomputed since it only depends on the $x$-coordinate of the shares that can be publicly known. $$f\\left(0\\right) = \\displaystyle\\sum_{j=1}^{k}{y_{j}\\left(\\displaystyle\\prod_{\\begin{smallmatrix}1\\leq m\\leq k\\\\ m\\neq j\\end{smallmatrix}}{\\frac{x_m}{x_m - x_j}}\\right)}$$\nThe Lagrange interpolating polynomial is popular because it\u0026rsquo;s fast enough for several use cases and relatively simple to implement.\nThe Zero Share Problem #  How Shares are Generated #  As mentioned above, there are several ways to select the $x_{i}$ values during the share-generation phase of the algorithm.\nThe most common approach, and the one we recommend, is to use a counter, setting $x_{i}=i$ for $i=1,2,\\ldots,n$. This has the advantage of simplicity and speed. No user-generated inputs are necessary, and evaluating $f\\left(x\\right)$ when $x$ is small can be faster than for arbitrary-selected values in the field.\nAnother approach is to use unique values associated with shareholders, such as userid values from a database, or users\u0026rsquo; provided values.\nFinally, some implementations select $x_{i}$ by selecting them randomly from $\\field{p}$.\nWhat Can Go Wrong? #   Zero share problem: If it is possible to wind up with $x_{i}=0$ for some $i$, the corresponding share is $\\left(0, S\\right)$, revealing $S$ directly to the $i$-th shareholder. This is not a hypothetical attack; several instances of this problem have been spotted in the wild. Implementations must guarantee that all $x_i$ are modularly nonzero. Non-unique shares: The $x_i$ for each value must be modularly unique; when users reconstruct the secret from a share, they need to compute $\\frac{x_m}{x_m-x_j}$. If the polynomial is evaluated modulo $q$ and if $x_m\\equiv x_j \\pmod{q}$, the modular inverse of $(x_m-x_j)$ does not exist and the protocol does not work. Some applications do not check if this modular inverse exists and usually do not handle this gracefully.  How Things Go Wrong #    Counter-based shares: One of the most common control structures in programming is a loop with a starting index of i = 0. The line for(int i = 0; i \u0026lt; n; i++) is near-idiomatic in C; for i in range(n): is an idiom in Python. It\u0026rsquo;s easy to fall into an old pattern and fail to update these to the correct for(int i = 1; i \u0026lt;= n; i++) and for i in range(1, n + 1):, respectively. An initial draft of this page included this very error in the \u0026ldquo;correct\u0026rdquo; C loop! This common error is enough to destroy the security of the system entirely.\n  Userid-based shares: Trusting unique user identifiers is problematic, too. A user can have a userid of 0 in plenty of systems. Trusting user-supplied values in security-critical contexts is never a good idea. Even if you compare the userid with 0, you might fail to do it correctly: since the polynomial evaluates over the finite field $\\field{p}$, you need to check if it is 0 in $\\field{p}$. In the case of the integers modulo a prime number, you must check that the userid is modularly different from zero. Even transforming user inputs can be problematic if you\u0026rsquo;re not careful. For instance, given a user input $n$, a program may try to avoid this issue by taking the $x$-coordinate of $n\\cdot G$, where $G$ is a generator of an elliptic curve group. However, if $n$ is 0, the resulting point is the \u0026ldquo;point at infinity\u0026rdquo;. With some curve parameterizations, the point at infinity is represented as $\\left(0,1\\right)$.\n  Random shares: Selecting random values seems safeâ€“ in theory, the probability of selecting 0 from $\\field{p}$ is $\\frac{1}{p}$. But winding up with a zero share is significantly more likely than that. Consider the case where a program generates random numbers by reading from /dev/random. For Linux kernels before version 5.6, it is possible for /dev/random to block when the \u0026ldquo;entropy runs out\u0026rdquo;. Since Linux 5.6, /dev/random can still block if the PRNG has not been initialized. If a programmer does not check the return value of the read function, then depending on how the destination buffer is allocated, the destination buffer can be left in a zeroed state, leading to a zero share.\n  "},{"id":19,"href":"/docs/zkdocs/protocol-primitives/verifiable-secret-sharing/","title":"Feldman's Verifiable Secret Sharing","section":"Protocol primitives","content":"Feldman\u0026rsquo;s Verifiable Secret Sharing #  As Feldman first introduced, Verifiable secret sharing is an extension to Shamir\u0026rsquo;s secret sharing scheme. The idea is that, when generating shares of the secret $S$, the splitting party also generates a set of public values that shareholders can use to validate their shares.\nFor simplicity, we will use \u0026ldquo;Sherry\u0026rdquo; to refer to the party generating the shares of a secret $S$. We denote a share using a lower-case $s$, and a shareholder (or player) as $P$. We will assume a $\\left(k, n\\right)$ threshold scheme, meaning that $k$ shares are enough to recover $S$ and fewer do not obtain any information about $S$. In some protocols, the players may perform the reconstruction, independently or collaboratively.\nShare Generation and Verification #  Share Generation #  In standard Shamir secret sharing, Sherry generates a polynomial $$ f \\left( x\\right) = a_{0} + a_{1} x + \\cdots + a_{k-1} x^{k-1} \\in \\mathbb{F}\\left[x\\right] \\enspace ,$$ where $a_{0}=S$ and $\\mathbb{F}$ is a finite field of characteristic $p$, where $p$ is a suitably large prime. Shares are generated as $s_{i}=\\left(x_{i},f\\left(x_{i}\\right)\\right)$ for $i=1,\\ldots,n$. Sherry then sends $s_{i}$ to $P_{i}$ over a secure channel. Shares are generated the same way in Feldman\u0026rsquo;s scheme.\nFeldman\u0026rsquo;s scheme extends Shamir\u0026rsquo;s scheme by having Sherry extend the shares to include verification values, as well as publicly share an additional set of values that each player $P_{i}$ can use to verify that their share $s_{i}$ is valid.\nThe public values are generated by translating them into elements a commutative group $G$ for which the discrete logarithm problem is hard. For expository purposes, we\u0026rsquo;ll start with $\\z{q}$, the multiplicative group of integers modulo a large prime $q$, where $q-1$ is divisible by a large prime $r$, and a generator value $g\\in\\z{q}$ such that $\\left|g\\right|=r$.\nVerification Values #  Let $A_{j}=g^{a_{j}}\\pmod{q}$ for $j=0,\\ldots,k-1$. These are the verification values, and Sherry publishes all of them on a public broadcast channel.\nRecovering any $a_{j}$ values from the corresponding $A_{j}$ would require solving a discrete logarithm problem over $\\z{q}$, which is presumed to be hard. Note that $A_{0}=g^{a_{0}}=g^{S}\\pmod{q}$; solving the discrete log for $A_{0}$ would recover $S$ directly.\nVerification of Shares #  To verify their share $s_{i}=\\left(x_{i},f\\left(x_{i}\\right)\\right)$, player $P_{i}$ computes:\n$$ V_{i}=\\prod_{j=0}^{k-1}{A_{j}^{x_{i}^{j}}} \\enspace . $$\nFor each $j$, we have $A_{j}=\\left(g^{a_{j}}\\right)^{x_{i}^{j}}=g^{a_{j}\\cdot x_{i}^{j}}$, which means\n$$ V_{i}=g^{a_{0}} g^{a_{1}\\cdot x_{i}} g^{a_{2}\\cdot x_{i}^{2}}\\cdots g^{a_{k-1}\\cdot x_{i}^{k-1}}=g^{a_{0} + a_{1}\\cdot x_{i} + \\cdots + a_{k-1}\\cdot x_{i}^{k-1}}=g^{f\\left(x_{i}\\right)} $$\nSince $P_{i}$ knows $f\\left(x_{i}\\right)$ as part of their share, they can compute $V_{i}\u0026rsquo;=g^{f\\left(x_{i}\\right)}$ directly from the value of $f\\left(x_{i}\\right)$ given in $s_{i}$. If $V_{i}\u0026rsquo;=V_{i}$, then $P_{i}$ accepts $s_{i}$ as valid; otherwise, they reject $s_{i}$.\nVariations #  Feldman points out that it is not necessary to use $\\z{q}$ for generating the verification values. The paper discusses using elliptic curves over finite fields. Using the more familiar point multiplication notation for an elliptic curve group $G$ with a generator point $P\\in G$, we have $V_{i}=\\left[a_{0}\\right]P+\\left[a_{1}x_{i}\\right]P+\\cdots +\\left[a_{k-1}x_{i}^{k-1}\\right]P=Y_{i}$.\nSecurity pitfalls #   Forgery attack: Craige describes a forgery attack against Feldman\u0026rsquo;s technique when broadcast channels are incorrectly implemented. If an attacker can change each player\u0026rsquo;s view of a single $A_{j}$ value, then it is possible to forge invalid shares for each player that will pass the verification step. Zero share attacks: All of the pitfalls of Shamir\u0026rsquo;s secret sharing scheme (e.g., generation of zero shares) still apply. Improper parameter choice: The $p$, $q$, and $g$ values should be selected with care. While Shamir\u0026rsquo;s original paper suggested using $p=2^{16}-15=65521$, this will limit the coefficients to 16 bits; recovering the $a_{j}$ values from their corresponding $A_{j}$ values becomes trivial. Further, improper selection of $q$ or $g$ can lead to several discrete log attacks.  "},{"id":20,"href":"/docs/zkdocs/protocol-primitives/alt-shamir/","title":"Alternative versions of Shamir's Secret Sharing scheme","section":"Protocol primitives","content":"Alternative Secret Sharing Solutions #  There are multiple ways to prevent inadvertently sharing the secret value by evaluating the polynomial at zero. In Shamir Secret Sharing, we described defense strategies to solve that problem in classical Shamir\u0026rsquo;s Secret Sharing scheme. Here, we describe alternative implementations of Shamir\u0026rsquo;s scheme, which ensure that evaluating $f\\left(0\\right)$ does not reveal $S$.\nThese alternative schemes are certainly harder to implement (and to review), and their added complexity might not be worth the ability to mistakenly leak $f(0)$, since they can still leak the secret value by leaking other points of the polynomial.  Transforming the Inputs Using a Nonzero Function #  Suppose we are working over $\\z{p}$, where $p=2^{255}-19$. Consider the multiplicative group $\\zns{p}$ of integers less than $p$ and relatively prime to $p$. We can define $h\\left(m\\right)=2^{m}\\pmod{p}$. Since $0\\not\\in \\zns{p}$, we know that $h\\left(m\\right)\\neq 0$ for any integer $m$. Since $2$ is a generator of $\\zns{p}$, we know that $h\\left(m\\right)$ has maximal order in $\\zns{p}$.\nDuring share generation, given an integer input $x$, define $x\u0026rsquo;=h\\left(x\\right)$. Then, generate the corresponding share according to $\\left(x\u0026rsquo;,f\\left(x\u0026rsquo;\\right)\\right)$. Because $x\u0026rsquo;\\neq 0$, counters and external inputs can be used without the risk of generating a zero share.\nThis technique is compatible with the secret reconstruction using Lagrange interpolation: as far as the Lagrange interpolating polynomial goes, a share formed from the transformed values works the same as any other shares.\nAvoiding the $y$-intercept #  It is possible to encode the secret $S$ into a polynomial such that $f\\left(t\\right)=S$ for a value $t\\neq 0$. The process is only a little more complicated than the standard Shamir scheme:\n Select a non-zero $t\\in\\field{p}$ Select a random degree-$(k-1)$ polynomial $g\\left(x\\right)\\in\\field{p}\\left[x\\right]$ Compute $S\u0026rsquo;=S-g\\left(t\\right)$ Set the final polynomial to $f\\left(x\\right)=g\\left(x\\right)+S'$  We now have $f\\left(t\\right)=g\\left(t\\right)+S\u0026rsquo;=g\\left(t\\right)+S-g\\left(t\\right)=S$. The Lagrange interpolating polynomial can compute $f\\left(x\\right)$ at $x=t$ just as easily as at $x=0$.\nIf shares are generated sequentially, selecting a value of $t$ larger than any reasonable number of shares $n$ (e.g., $t\\gg 2^{64}$) can prevent creating an insecure share of the form $\\left(t,f\\left(t\\right)\\right)$.\nIf shares are generated randomly, it\u0026rsquo;s still possible to wind up with an insecure share by randomly selecting $t$. However, generating this value at random is significantly less likely than accidentally \u0026ldquo;generating\u0026rdquo; a zero share from a blocked read.\nMoving Away from the Constant Term #  There is no requirement that $S$ be encoded into $f\\left(x\\right)$ through the manipulation of the constant coefficient. It\u0026rsquo;s possible to encode $S$ into, say, the linear coefficient of $f\\left(x\\right)$. Recovering the linear coefficient is straightforward, once you realize that the linear term of $f\\left(x\\right)$ is the constant term of $f\u0026rsquo;\\left(x \\right)$, the derivative of $f\\left(x\\right)$.\nThe process for generating a polynomial becomes:\n Generate a random, degree-$(k-3)$ polynomial $g\\left(x\\right)$ Select a random $c\\in\\field{p}$ Set $f\\left(x\\right)=g\\left(x\\right)x^2+Sx+c$  The Lagrange interpolating polynomial can be adapted to evaluate derivatives of polynomials; the equation used to compute the first derivative is below. The equation is slightly more complicated than before but certainly within the capability of a good programmer.\n$$f\u0026rsquo;\\left(t\\right)=\\displaystyle\\sum_{j=1}^{k}{y_{j}\\left(\\displaystyle\\sum_{\\begin{smallmatrix}i=1\\\\ i\\neq j\\end{smallmatrix}}^{k}{\\left[\\frac{1}{x_{j}-x_{i}}\\displaystyle\\prod_{\\begin{smallmatrix}m=1\\\\ m\\neq i,j\\end{smallmatrix}}^{k}{\\frac{t-x_{m}}{x_{j}-x_{m}}}\\right]}\\right)}$$\nEvaluating $f\u0026rsquo;\\left(0\\right)$ gives the linear coefficient of $f\\left(x\\right)$, recovering $S$.\nRequiring Recovery of the Full Polynomial #  Finally, it\u0026rsquo;s possible to encode the secret across all coefficients of $f\\left(x\\right)$. Take $g\\left(x\\right)=\\displaystyle\\sum_{i=0}^{k-1}{a_{i}x^{i}}$ , where each $a_{i}$ is chosen uniformly at random (except that $a_{k-1}\\neq 0$), then we can set $M=\\displaystyle\\sum_{i=0}^{k-1}{a_{i}}$ and $R=S - M$. We then select a random $0\\leq i\\leq k-1$ and set $f\\left(x\\right)=g\\left(x\\right)+Rx^i$. Then the sum of the coefficients is equal to $S$.\nGoing back to the original Lagrange interpolating polynomial equation, if $t$ is replaced with a symbol $x$, the Lagrange interpolating polynomial recovers $f\\left(x\\right)$ exactly. $S$ can then be recovered from the reconstructed polynomial. Symbolic computations are more expensive and slightly more complex, but for, say, $k\u0026lt;30$, the algorithm works just fine.\n"},{"id":21,"href":"/docs/zkdocs/bibliography/","title":"Bibliography","section":"Introduction","content":"References #  Here, we gather a list with all references used throughout the website, sorted by year.\n [Sha79] Shamir, A. (1979). How to share a secret. Communications of the ACM, 22(11), 612-613. (1979).   [Fel87] Feldman, P. (1987, October). A practical scheme for non-interactive verifiable secret sharing. In 28th Annual Symposium on Foundations of Computer Science (sfcs 1987) (pp. 427-438). IEEE. (1987).   [Gir91] Girault, M. (1991, April). Self-certified public keys. In Workshop on the Theory and Application of of Cryptographic Techniques (pp. 490-497). Springer, Berlin, Heidelberg. (1991).   [Sch91] Schnorr, C. P. (1991). Efficient signature generation by smart cards. Journal of cryptology, 4(3), 161-174 (1991).   [FO97] Fujisaki, E., \u0026amp; Okamoto, T. (1997, August). Statistical zero knowledge protocols to prove modular polynomial relations. In Annual International Cryptology Conference (pp. 16-30). Springer, Berlin, Heidelberg. (1997).   [PS00] Poupard, G., \u0026amp; Stern, J. (2000, January). Short proofs of knowledge for factoring. In International Workshop on Public Key Cryptography (pp. 147-166). Springer, Berlin, Heidelberg. (2000).   [Poi00] Pointcheval, D. (2000, January). The composite discrete logarithm and secure authentication. In International Workshop on Public Key Cryptography (pp. 113-128). Springer, Berlin, Heidelberg. (2000).   [BPW12] Bernhard, D., Pereira, O., \u0026amp; Warinschi, B. (2012, December). How not to prove yourself: Pitfalls of the Fiat-Shamir heuristic and applications to Helios. In International Conference on the Theory and Application of Cryptology and Information Security (pp. 626-643). Springer, Berlin, Heidelberg (2012).   [GGN16] Gennaro, R., Goldfeder, S., \u0026amp; Narayanan, A. (2016, June). Threshold-optimal DSA/ECDSA signatures and an application to Bitcoin wallet security. In International Conference on Applied Cryptography and Network Security (pp. 156-174). Springer, Cham. (2016).   [SHA3] Kelsey, J., Chang, S. J., \u0026amp; Perlner, R. (2016). SHA-3 derived functions: cSHAKE, KMAC, TupleHash and ParallelHash. NIST special publication, 800, 185. (2016).   [RFC] RFC: Schnorr Non-interactive Zero-Knowledge Proof (2017).   [AP18] Auerbach, B., \u0026amp; Poettering, B. (2018, March). Hashing solutions instead of generating problems: on the interactive certification of RSA moduli. In IACR International Workshop on Public Key Cryptography (pp. 403-430). Springer, Cham. (2018).   [HOC] Menezes, A. J., Van Oorschot, P. C., \u0026amp; Vanstone, S. A. (2018). Handbook of Applied Cryptography. CRC press. (2018).   [GRSB19] Goldberg, S., Reyzin, L., Sagga, O., \u0026amp; Baldimtsi, F. (2019, December). Efficient noninteractive certification of RSA moduli and beyond. In International Conference on the Theory and Application of Cryptology and Information Security (pp. 700-727). Springer, Cham. (2019).   [GG21] Canetti, R., Gennaro, R., Goldfeder, S., Makriyannis, N., \u0026amp; Peled, U. (2020, October). UC non-interactive, proactive, threshold ECDSA with identifiable aborts. In Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security (pp. 1769-1787). (2020).   [NSPUE2] National Institute of Standards and Technology (2020, May). Recommendation for Key Management: Part 1 â€” General. Special Publication 800-57 Part 1, Revision 5 (2020).  "}]