<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In this section, we describe how to uniformly sample from different groups."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="In this section, we describe how to uniformly sample from different groups."><meta property="og:type" content="article"><meta property="og:url" content="https://www.zkdocs.com/docs/zkdocs/protocol-primitives/random-sampling/"><meta property="article:section" content="docs"><title>Random Sampling | ZKDocs</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.6aece0f96007af353373ec1c05beb9d415830db47ac294f964054d8382bbb1e3.css integrity="sha256-auzg+WAHrzUzc+wcBb651BWDDbR6wpT5ZAVNg4K7seM=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.efb8dda88c29c848a340ea08957296610e56a3fd40e2b12ef92e19a7cabeac93.js integrity="sha256-77jdqIwpyEijQOoIlXKWYQ5Wo/1A4rEu+S4Zp8q+rJM=" crossorigin=anonymous></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-215689345-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript id=hs-script-loader async defer src=//js.hs-scripts.com/22554992.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class=align-center href=/><img id=icon src=/TOB_Black.svg alt=Logo><div class="flex align-center"><img id=logo src=/logo.png alt=Logo><span>ZKDocs</span></div></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=https://www.zkdocs.com/docs/zkdocs/>Introduction</a><ul><li><a href=https://www.zkdocs.com/docs/zkdocs/notation/>Notation & Definitions</a></li><li class=book-section-flat><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/>Zero-knowledge protocols</a><ul><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/schnorr/>Schnorr's identification protocol</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/schnorr-variants/>Variants of Schnorr's identification protocol</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/product-primes/>Number is product of two primes</a><ul><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/product-primes/square-freeness/>Number is square-free</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/product-primes/two-prime-divisors/>Two prime divisors</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/product-primes/product-of-two-primes/>Product of two primes</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/product-primes/paillier_blum_modulus/>Paillier-Blum Modulus</a></li></ul></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/girault-identification/>Girault's identification protocol</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/short-factoring-proofs/>Short factoring proofs</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/zero-knowledge-protocols/ipa/>Inner Product Argument</a></li></ul></li><li class=book-section-flat><a href=https://www.zkdocs.com/docs/zkdocs/security-of-zkps/>Security of ZKPs</a><ul><li><a href=https://www.zkdocs.com/docs/zkdocs/security-of-zkps/when-to-use-hvzk/>Using HVZKP in the wrong context</a></li></ul></li><li class=book-section-flat><a href=https://www.zkdocs.com/docs/zkdocs/protocol-primitives/>Protocol primitives</a><ul><li><a href=https://www.zkdocs.com/docs/zkdocs/protocol-primitives/random-sampling/ class=active>Random Sampling</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/protocol-primitives/fiat-shamir/>Fiat-Shamir transformation</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/protocol-primitives/nums/>Nothing-up-my-sleeve constructions</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/protocol-primitives/shamir/>Shamir's Secret Sharing Scheme</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/protocol-primitives/verifiable-secret-sharing/>Feldman's Verifiable Secret Sharing</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/protocol-primitives/alt-shamir/>Alternative versions of Shamir's Secret Sharing scheme</a></li></ul></li><li class=book-section-flat><a href=https://www.zkdocs.com/docs/zkdocs/commitments/>Commitment Schemes</a><ul><li><a href=https://www.zkdocs.com/docs/zkdocs/commitments/pedersen/>Pedersen Commitments</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/commitments/kzg_polynomial_commitment/>KZG Polynomial Commitments</a></li><li><a href=https://www.zkdocs.com/docs/zkdocs/commitments/ipa-pcs/>IPA Polynomial Commitment</a></li></ul></li><li><a href=https://www.zkdocs.com/docs/zkdocs/bibliography/>Bibliography</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><script type=text/x-mathjax-config>
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},SVG: {addMMLclasses: true},
  loader: { load: ['[tex]/textmacros','[tex]/newcommand','[tex]/action'] },
  tex: { packages: { '[+]': ['newcommand','action', 'textmacros'] } }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML-full"></script><script language=javascript type=text/javascript src=/js/interactive_variables.js></script><script>MathJax.Hub.Queue(function(){setupInteractiveVariables()})</script>$\newcommand{\coinheads}{\mathsf{HEADS}}$
$\newcommand{\cointails}{\mathsf{TAILS}}$
$\newcommand{\varalice}{\class{var var_Alice}{\text{Alice}}}$
$\newcommand{\varbob}{\class{var var_Bob}{\text{Bob}}}$
$\newcommand{\alicebob}[3]{#1 & \ra{#2} & #3\\[-5pt]}$
$\newcommand{\bobalice}[3]{#1 & \la{#2} & #3\\[-5pt]}$
$\newcommand{\alicework}[1]{#1 & &\\[-5pt]}$
$\newcommand{\bobwork}[1]{ & & #1\\[-5pt]}$
$\newcommand{\work}[2]{#1 & & #2\\}$
$\newcommand{\allwork}[1]{ & #1 & \\}$
$\newcommand{\dupwork}[1]{#1 & & #1\\}$
$\newcommand{\aliceseparator}{-------&&\\}$
$\newcommand{\bobseparator}{&&-------\\}$
$\newcommand{\foo}{\phantom{\text{bigarrowfitsallthis}}}$
$\newcommand{\ra}[1]{%
\vphantom{\xrightarrow{asd}}%
\smash{\xrightarrow[\foo]{#1}}%
}$
$\newcommand{\la}[1]{%
\vphantom{\xleftarrow{asd}}%
\smash{\xleftarrow[\foo]{#1}}%
}$
$\newcommand{\z}[1]{\mathbb{Z}_{#1}}$
$\newcommand{\zq}{\mathbb{Z}_\varq}$
$\newcommand{\zqs}{\mathbb{Z}_q^\ast}$
$\newcommand{\zps}{\mathbb{Z}_p^\ast}$
$\newcommand{\zns}[1]{\mathbb{Z}_{#1}^\ast}$
$\require{action}
\newcommand{\sampleSymb}{
{\overset{\$}{\leftarrow}}
}$
$\newcommand{\field}[1]{\mathbb{F}_{#1}}$
$\newcommand{\sample}[1]{#1\sampleSymb\zq}$
$\newcommand{\sampleGeneric}[2]{#1\sampleSymb#2}$
$\newcommand{\sampleInterval}[2]{#1\sampleSymb\interval{#2}}$
$\newcommand{\sampleRange}[2]{#1\sampleSymb\range{#2}}$
$\newcommand{\sampleCgroup}[1]{#1\sampleSymb\cgroup}$
$\newcommand{\samplezqs}[1]{\class{hover}{#1\sampleSymb\zqs}}$
$\newcommand{\sampleN}[2]{\class{hover}{#1\sampleSymb\z{#2}}}$
$\newcommand{\sampleNs}[2]{\class{hover}{#1\sampleSymb\z{#2}^\ast}}$
$\newcommand{\equalQ}{\overset{?}{=}}$
$\newcommand{\gQ}{\overset{?}{>}}$
$\newcommand{\inQ}{\overset{?}{\in}}$
$\newcommand{\cgroup}{\mathbb{G}}$
$\newcommand{\Hash}{\mathsf{Hash}}$
$\newcommand{\hash}[1]{\Hash({#1})}$
$\newcommand{\HashToField}{\mathsf{HashToField}}$
$\newcommand{\hashtofield}[1]{\HashToField({#1})}$
$\newcommand{\HashToGroup}{\mathsf{HashToGroup}}$
$\newcommand{\hashtogroup}[1]{\HashToGroup({#1})}$
$\newcommand{\hashbit}[2]{\mathsf{Hash}({#1})\verb+[0:#2]+}$
$\newcommand{\hmac}[2]{\mathsf{HMAC}_{#1}\left(#2\right)}$
$\newcommand{\naturals}{\mathbb{N}}$
$\newcommand{\sqfree}{L_\mathsf{square-free}}$
$\newcommand{\ceil}[1]{\lceil #1 \rceil}$
$\newcommand{\sampleSet}[2]{\class{hover}{#1\sampleSymb#2}}$
$\newcommand{\bunch}[1]{\{ #1_i\}_{i=1}^m}$
$\newcommand{\bunchi}[1]{\{ #1\}_{i=1}^m}$
$\newcommand{\forb}{\text{ for }i=1,\ldots,m}$
$\newcommand{\interval}[1]{[0, #1[}$
$\newcommand{\range}[1]{[#1]}$
$\newcommand{\rangeone}[1]{\{1, \dots,#1 -1 \}}$
$\newcommand{\vara}{\class{var var_a}{a}}$
$\newcommand{\varb}{\class{var var_b}{b}}$
$\newcommand{\varc}{\class{var var_c}{c}}$
$\newcommand{\vard}{\class{var var_d}{d}}$
$\newcommand{\varh}{\class{var var_h}{h}}$
$\newcommand{\varH}{\class{var var_H}{H}}$
$\newcommand{\varg}{\class{var var_g}{g}}$
$\newcommand{\varG}{\class{var var_G}{G}}$
$\newcommand{\vari}{\class{var var_i}{i}}$
$\newcommand{\varj}{\class{var var_j}{j}}$
$\newcommand{\vars}{\class{var var_s}{s}}$
$\newcommand{\vart}{\class{var var_t}{t}}$
$\newcommand{\varu}{\class{var var_u}{u}}$
$\newcommand{\varU}{\class{var var_U}{U}}$
$\newcommand{\varl}{\class{var var_l}{l}}$
$\newcommand{\varm}{\class{var var_m}{m}}$
$\newcommand{\varn}{\class{var var_n}{n}}$
$\newcommand{\varx}{\class{var var_x}{x}}$
$\newcommand{\varX}{\class{var var_X}{X}}$
$\newcommand{\varz}{\class{var var_z}{z}}$
$\newcommand{\varr}{\class{var var_r}{r}}$
$\newcommand{\varq}{\class{var var_q}{q}}$
$\newcommand{\varp}{\class{var var_p}{p}}$
$\newcommand{\vare}{\class{var var_e}{e}}$
$\newcommand{\vary}{\class{var var_y}{y}}$
$\newcommand{\varv}{\class{var var_v}{v}}$
$\newcommand{\varw}{\class{var var_w}{w}}$
$\newcommand{\varC}{\class{var var_C}{C}}$
$\newcommand{\varf}{\class{var var_f}{f}}$
$\newcommand{\varA}{\class{var var_A}{A}}$
$\newcommand{\varB}{\class{var var_B}{B}}$
$\newcommand{\varC}{\class{var var_C}{C}}$
$\newcommand{\varL}{\class{var var_L}{L}}$
$\newcommand{\varP}{\class{var var_P}{P}}$
$\newcommand{\varR}{\class{var var_R}{R}}$
$\newcommand{\varT}{\class{var var_T}{T}}$
$\newcommand{\varX}{\class{var var_X}{X}}$
$\newcommand{\varalpha}{\class{var var_alpha}{\alpha}}$
$\newcommand{\varprover}{\class{var var_Prover}{\text{Prover}}}$
$\newcommand{\varprover}{\class{var var_Prover}{\text{Prover}}}$
$\newcommand{\varverifier}{\class{var var_Verifier}{\text{Verifier}}}$
$\newcommand{\varN}{\class{var var_N}{N}}$
$\newcommand{\rhovar}{\class{var var_ρ}{\rho}}$
$\newcommand{\sigmavar}{\class{var var_σ}{\sigma}}$
$\newcommand{\thetavar}{\class{var var_θ}{\theta}}$
$\newcommand{\muvar}{\class{var var_μ}{\mu}}$
$\renewcommand{\vec}[1]{\mathbf{#1}}$
$\newcommand{\veca}{\vec{\class{var var_vec_a}{a}}}$
$\newcommand{\vecb}{\vec{\class{var var_vec_b}{b}}}$
$\newcommand{\vecc}{\vec{\class{var var_vec_c}{c}}}$
$\newcommand{\vecs}{\vec{\class{var var_vec_s}{s}}}$
$\newcommand{\vecG}{\vec{\class{var var_vec_G}{G}}}$
$\newcommand{\vecH}{\vec{\class{var var_vec_H}{H}}}$
$\newcommand{\vecg}{\vec{\class{var var_vec_g}{g}}}$
$\newcommand{\vech}{\vec{\class{var var_vec_h}{h}}}$
$\newcommand{\true}{\mathsf{true}}$
$\newcommand{\false}{\mathsf{false}}$
$\newcommand{\ctx}{\mathsf{ctx}}$
$\newcommand{\coloneqq}{&#8788;}$
$\newcommand{\ip}[2]{\left\langle #1, #2 \right\rangle}$
$\newcommand{\uwork}[2]{\underline{#1} & & \underline{#2}\\}$

$\newcommand{\aliceworks}[1]{#1 & &\\[-2pt]}$
$\newcommand{\bobworks}[1]{ & & #1\\[-2pt]}$

$\newcommand{\Halving}{\text{Halving}}$
$\newcommand{\HalveProof}{\text{HalveProof}}$
$\newcommand{\HalveVerify}{\text{HalveVerify}}$
$\newcommand{\indent}{\qquad}$
$\newcommand{\append}{\mathrm{append}}$
$\newcommand{\schnorrvalidate}{\mathsf{schnorr}\_\mathsf{validate}}$<div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Random Sampling</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#sampling-from-zq>Sampling from $\zq$</a><ul><li><a href=#almost-uniform-sampling-in-zq-using-modular-reduction>Almost-uniform sampling in $\zq$ using modular reduction</a></li><li><a href=#modulo-bias>Modulo Bias</a></li></ul></li><li><a href=#rejection-sampling>Rejection sampling</a><ul><li><a href=#uniform-sampling-in-zqs>Uniform sampling in $\zqs$</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=random-sampling>Random sampling
<a class=anchor href=#random-sampling>#</a></h1><p>In most protocols, it is necessary to sample uniformly from groups like $\zq$ or $\zqs$. Here we will describe how to sample in these specific groups, and a general procedure to sample via rejection sampling.</p><p>When available it is advisable to use a cryptographic random number library to securely sample at uniform from a range. For example, to sample uniformly from $\zq$ (or equivalently $\range{q}$) in Python, use the <a href=https://docs.python.org/3/library/secrets.html>secrets</a> library.</p><div class=highlight><div style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>secrets</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>sample_Zq</span>():
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> secrets<span style=color:#666>.</span>randbelow(q)
</span></span></code></pre></td></tr></table></div></div><h2 id=sampling-from-zq>Sampling from $\zq$
<a class=anchor href=#sampling-from-zq>#</a></h2><p>Sampling uniformly from $\zq$ is equivalent to sampling uniformly from the set of representatives, i.e. the range $\range{q}$. We present two secure methods for doing so: wide modular reduction gives samples from an almost-uniform distribution with a (deterministic) logarithmic number of random bits, while rejection sampling gives samples from a truly uniform distribution using a logarithmic number of bits <em>with high probability</em>.</p><h3 id=almost-uniform-sampling-in-zq-using-modular-reduction>Almost-uniform sampling in $\zq$ using modular reduction
<a class=anchor href=#almost-uniform-sampling-in-zq-using-modular-reduction>#</a></h3><p>Suppose we only have a cryptographically-secure random bit generator and we would like to sample uniformly from the range $[q]$. As an example we will use the secp256k1 curve order
$$
q = 2^{256} - 432420386565659656852420866394968145599
$$</p><blockquote class="book-hint danger"><p><strong>Never do this:</strong></p><div class=highlight><div style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>wrong_sampling</span>():
</span></span><span style=display:flex><span>    q <span style=color:#666>=</span> <span style=color:#40a070>2</span><span style=color:#666>**</span><span style=color:#40a070>256</span> <span style=color:#666>-</span> <span style=color:#40a070>432420386565659656852420866394968145599</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> randbits(<span style=color:#40a070>256</span>) <span style=color:#666>%</span> q
</span></span></code></pre></td></tr></table></div></div><p>The <code>wrong_sampling</code> function introduces non-negligible <em>modulo-bias</em> in the generation of elements, and some elements will be detectably more likely to appear than others. If the random number is used as an ECDSA nonce, this <a href=https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/>may be enough to fully compromise the key</a>.</p></blockquote><p>Instead, sample at least 512 bits:</p><div class=highlight><div style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>from</span> <span style=color:#0e84b5;font-weight:700>secrets</span> <span style=color:#007020;font-weight:700>import</span> randbits
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>correct_sampling</span>():
</span></span><span style=display:flex><span>    q <span style=color:#666>=</span> <span style=color:#40a070>2</span><span style=color:#666>**</span><span style=color:#40a070>256</span> <span style=color:#666>-</span> <span style=color:#40a070>432420386565659656852420866394968145599</span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> randbits(<span style=color:#40a070>512</span>) <span style=color:#666>%</span> q
</span></span></code></pre></td></tr></table></div></div><p>In general, if the overall security level of your system is $\lambda$ bits (e.g., 128), then to safely sample from the range $[q]$ where $2^{n-1} &lt; q &lt; 2^{n}$, it is necessary to reduce
$n + \lambda$ cryptographically random bits mod $q$.</p><h3 id=modulo-bias>Modulo Bias
<a class=anchor href=#modulo-bias>#</a></h3><p>A common approach to sampling from a range $[q]$ is to generate a random bit string $b \in \{0,1\}^n$, interpret it as a natural number in the range $[2^n - 1]$, then return $x = b\mod q$. However, this process introduces <em>modulo bias</em>. As a simple example where $q = 3, n = 2$, let $b$ be uniformly drawn from $\{0,1\}^2 \cong [4]$ and let $x = b \mod 3$. Then
$$
\begin{align*}
&\Pr[x = 0] = \Pr[b = 0 \vee b = 3] = 1/2\\
&\Pr[x = 1] = \Pr[b = 1] = 1/4\\
&\Pr[x = 2] = \Pr[b = 2] = 1/4\\
&\end{align*}
$$</p><p>Intuitively, the bias arises because some elements of $\zq$ are double-counted. In order to minimize the modulo bias, we can increase the number of random bits drawn. For $q = 3$ and $n = 8$,
$$\Pr[x = 0] = \frac{86}{256} = \frac{1}{3} + \frac{1}{384}$$</p><p>For $n = 256$
$$\Pr[x = 0] = \frac{1}{3} + \frac{1}{3\cdot 2^{255}}$$
No real-world adversary can distinguish the distribution generated in the $n = 256$ case from the uniform distribution on $\mathbb{Z}_3$.</p><p>In general, if $q$ is an $n$-bit integer, i.e. $2^{n-1} \leq q &lt; 2^n$ and $X$ is a random variable drawn uniformly from $[2^{n + \lambda}]$ where $\lambda \in \mathbb{N}$ is some security parameter, then for any $a \in \range{q}$</p><p>$$
\left|\Pr[X \equiv a \mod q] - \frac{1}{q}\right| \leq \frac{1}{2^{\lambda}}
$$</p><p>In practice, if $q$ is $n$ bits then typically $\lambda \leq n$, so it suffices to sample $2n$ bits and reduce mod $q$. For example, the ed25519 nonce generation proceeds by reducing the output of HMAC-SHA512 modulo the 255-bit order of the curve.</p><h4 id=statistical-distance>Statistical Distance
<a class=anchor href=#statistical-distance>#</a></h4><p>The <em>statistical distance</em>, also known as the &ldquo;total variational distance&rdquo; of the distribution of a random variable $X$ from that of another random variable $Y$ both with support $[q]$ is defined as
$$
\Delta(X,Y) = \frac{1}{2}\sum_{a = 0}^q |\Pr[X = a] - \Pr[Y = a]|
$$</p><p>The statistical distance gives an upper bound on the success probability of any adversary at distinguishing two distributions. For any function $A: [q] \rightarrow \{0,1\}$:</p><p>$$
|\Pr[A(X) = 1] - \Pr[A(Y) = 1]| \leq \Delta(X, Y)
$$
and in fact if $X_1, \dots X_n$ are identically and independent distributed and similarly for $Y_1, \dots, Y_n$ then</p><p>$$
|\Pr[A(X_1, \dots, X_n) = 1] - \Pr[A(Y_1, \dots, Y_n) = 1]| \leq n \cdot \Delta(X_1, Y_1)
$$</p><p>Letting $U$ be the uniform distribution over $[q]$, define $S(X) = \Delta(X, U)$. It follows that if $S(X) \leq 2^{-\lambda}$ then no adversary can distinguish $X$ from the uniform distribution with probability more than $1/2$ using fewer than $2^{\lambda - 1}$ samples.</p><h4 id=statistical-distance-of-wide-modular-reduction>Statistical distance of wide modular reduction
<a class=anchor href=#statistical-distance-of-wide-modular-reduction>#</a></h4><p>Let $X_{n}$ denote random variable resulting from sampling uniformly in $[2^n]$ and reducing modulo $q$. Let $U$ be a random variable uniformly distributed over $q$.
We can compute the statistical distance of $X_n$ from $U_{q}$ explicitly:
Let $2^n = k\cdot q + r$ for $0 \leq r &lt; q$. Then for all $a &lt; r$</p><p>$$
\Pr[X = a] = \frac{k + 1}{2^n} = \frac{\frac{2^n - r}{q} + 1}{2^n} = \frac{2^n - r + q}{2^n q} = \frac{1}{q} + \frac{q - r}{2^n q}
$$</p><p>and so
$$
|\Pr[X = a] - 1/q| = \frac{q - r}{2^n q}
$$
while a similar computation for $a \geq r$ gives
$$
|\Pr[X = a] - 1/q| = \left|\frac{k}{2^n} - \frac{1}{q}\right| = \frac{r}{2^n q}
$$</p><p>and thus in total
$$
S(X) = \frac{1}{2}\sum_{a = 0}^{r-1} \frac{q - r}{2^n q} + \sum_{a = r}^{q-1} \frac{r}{2^n q} = \frac{r}{2} \cdot \frac{q - r}{2^n q} + \frac{q - r}{2} \cdot\frac{r}{2^n q} = \frac{r(q - r)}{2^n q}
$$</p><p>This formula tells us some interesting things about modulo bias:</p><ul><li>When $q$ is a power of 2 less than $2^n$ then $r = 0$, so there is no modulo bias</li><li>In the worst case, when $r = q/2$, $S(X) = q/2^{n+2}$. If we choose &ldquo;just enough&rdquo; bits, such that $2^{n-1} &lt; q &lt; 2^n$, then $S(X) \geq 1 / 8$. This is a very substantial advantage, enough to clearly distinguish from uniform after only a few trials.</li><li>If we $\lambda$ is a security parameter and $q$ is an $n$-bit number then by selecting $n + \lambda$ bits we get a statistical distance of at most $\frac{1}{2^{\lambda + 2}}$.</li></ul><h2 id=rejection-sampling>Rejection sampling
<a class=anchor href=#rejection-sampling>#</a></h2><p>Suppose we know how to sample from a set $S$ and would like to sample from an arbitrary subset $T\subseteq S$.
To do this, we need to check membership in $T$ and perform rejection sampling. In a loop:</p><ol><li>sample element $e \in S$.</li><li>if $e \in T$, return $e$, otherwise repeat step 1.</li></ol><p>On average this requires looping $|S|/|T|$ times. If $|S| \leq 2|T|$, the probability that we will need to sample more than $k$ elements from $S$ is at most $2^{-k}$. Thus as long as $|S|$ is not too much bigger than $|T|$, the rejection sampling algorithm almost always terminates in only a few iterations.</p><h3 id=uniform-sampling-in-zqs>Uniform sampling in $\zqs$
<a class=anchor href=#uniform-sampling-in-zqs>#</a></h3><p>Elements of $\zqs$ are natural numbers $e$ such that $e \in [q]$ and $\gcd(e, q) = 1$.
To sample these elements uniformly we need to perform rejection sampling.
In a loop,</p><ol><li>Sample element $e \in [q]$.</li><li>If $\gcd(e, q) = 1$ return $e$, otherwise repeat step 1.</li></ol><div class=highlight><div style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>secrets</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>math</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>sample_Zqstar</span>():
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>while</span> <span style=color:#007020;font-weight:700>True</span>:
</span></span><span style=display:flex><span>        e <span style=color:#666>=</span> secrets<span style=color:#666>.</span>randbelow(q)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>if</span> math<span style=color:#666>.</span>gcd(e, q) <span style=color:#666>==</span> <span style=color:#40a070>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#007020;font-weight:700>return</span> e
</span></span></code></pre></td></tr></table></div></div><blockquote class="book-hint info"><strong>Note:</strong>
Since $\gcd(0, q)$ is never 1, we could also sample $e$ from the set $\rangeone{q}$.</blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><article class=markdown><br><br><hr><div style=text-align:right><a href=https://github.com/trailofbits/zkdocs target=_blank>View on Github</a> | <a href=https://www.trailofbits.com/ target=_blank>Trail of Bits</a> |
<a href=https://blog.trailofbits.com/ target=_blank>Trail of Bits Blog</a></div><div style=text-align:right><small>ZKDocs content is licensed under a <a href=https://creativecommons.org/licenses/by/4.0/ target=_blank>Creative Commons Attribution 4.0 International license.</a></small></div></article></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#sampling-from-zq>Sampling from $\zq$</a><ul><li><a href=#almost-uniform-sampling-in-zq-using-modular-reduction>Almost-uniform sampling in $\zq$ using modular reduction</a></li><li><a href=#modulo-bias>Modulo Bias</a></li></ul></li><li><a href=#rejection-sampling>Rejection sampling</a><ul><li><a href=#uniform-sampling-in-zqs>Uniform sampling in $\zqs$</a></li></ul></li></ul></nav><br><br></div></aside></main></body></html>